(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["stripe-payment"],{

/***/ "/TfR":
/*!******************************************************************************************************************************************************!*\
  !*** /home/felix/PhpstormProjects/shopware-6/plugins/ShopwareStripePayment/src/Resources/storefront/card-selection/stripe-payment.card-selection.js ***!
  \******************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return StripePaymentCardSelection; });\n/* harmony import */ var src_script_service_http_client_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/script/service/http-client.service */ \"k8s9\");\n/* harmony import */ var src_script_plugin_system_plugin_class__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/script/plugin-system/plugin.class */ \"FGIj\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable import/no-unresolved */\n\n\n\nvar StripePaymentCardSelection =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(StripePaymentCardSelection, _Plugin);\n\n  function StripePaymentCardSelection() {\n    _classCallCheck(this, StripePaymentCardSelection);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(StripePaymentCardSelection).apply(this, arguments));\n  }\n\n  _createClass(StripePaymentCardSelection, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      this._client = new src_script_service_http_client_service__WEBPACK_IMPORTED_MODULE_0__[\"default\"](window.accessKey, window.contextToken);\n      this.stripeElements = [];\n      this.invalidFields = [];\n      this.options = _extends(StripePaymentCardSelection.options, this.options || {});\n      this.allCards = this.options.availableCards;\n      /* eslint-disable no-undef */\n\n      this.stripeClient = Stripe(this.options.stripePublicKey); // Save config\n\n      this.setSelectedCard(this.options.selectedCard); // Setup form on payment method changes\n\n      var paymentMethodElements = document.querySelectorAll('input.payment-method-input');\n      paymentMethodElements.forEach(function (element) {\n        element.addEventListener('change', function () {\n          _this.setupForm();\n        });\n      });\n      this.setupForm();\n    }\n    /**\n     * Saves the given card and removes all hidden Stripe fields from the form. If the card exists, its ID as well as\n     * its encoded data are added to the form as hidden fields.\n     *\n     * @param card A Stripe card object.\n     */\n\n  }, {\n    key: \"setSelectedCard\",\n    value: function setSelectedCard(card) {\n      this.selectedCard = card;\n\n      if (this.selectedCard) {\n        console.log(\"set card \".concat(JSON.stringify(card)));\n        this.selectedCardChanged = true;\n      }\n    }\n    /**\n     * Sets up the payment form by first unounting all Stripe elements that might be already mounted to the DOM and\n     * clearing all validation errors. Then, if a stripe card payment method is selected, mounts new Stripe Elements\n     * fields to the form and adds some observers to other fields as well as the form.\n     */\n\n  }, {\n    key: \"setupForm\",\n    value: function setupForm() {\n      // Reset form\n      this.unmountStripeElements();\n      this.invalidFields = [];\n      this.updateValidationErrors();\n\n      if (this.getActiveStripeCardForm()) {\n        this.getStripeCardForm().show(); // Mount Stripe form fields again to the now active form and add other observers\n\n        this.mountStripeElements();\n        this.observeForm(); //TODO: remove listeners as well on change\n        // Make sure the card selection matches the internal state\n\n        if (this.selectedCard) {\n          this.formEl('.stripe-saved-cards').val(this.selectedCard.id);\n        }\n\n        this.formEl('.stripe-saved-cards').trigger('change');\n      } else {\n        this.getStripeCardForm().hide();\n      }\n    }\n    /**\n     * Creates the Stripe Elements fields for card number, expiry and CVC and mounts them to their resepctive nodes in\n     * the active Stripe card payment form.\n     */\n\n  }, {\n    key: \"mountStripeElements\",\n    value: function mountStripeElements() {\n      // Define options to apply to all fields when creating them\n      var cardHolderFieldEl = this.formEl('.stripe-card-holder');\n      var defaultOptions = {\n        style: {\n          base: {\n            color: cardHolderFieldEl.css('color'),\n            fontFamily: cardHolderFieldEl.css('font-family'),\n            fontSize: cardHolderFieldEl.css('font-size'),\n            fontWeight: cardHolderFieldEl.css('font-weight'),\n            lineHeight: cardHolderFieldEl.css('line-height')\n          }\n        }\n      }; // Define a closure to create all elements using the same 'Elements' instance\n\n      var elements = this.stripeClient.elements({\n        locale: this.options.locale\n      });\n      var me = this;\n\n      var createAndMountStripeElement = function createAndMountStripeElement(type, mountSelector) {\n        // Create the element and add the change listener\n        var element = elements.create(type, defaultOptions);\n        element.on('change', function (event) {\n          if (event.error && event.error.type === 'validation_error') {\n            me.markFieldInvalid(type, event.error.code, event.error.message);\n          } else {\n            me.markFieldValid(type);\n          }\n        }); // Mount it to the DOM\n\n        var mountElement = me.formEl(mountSelector).get(0);\n        element.mount(mountElement);\n        return element;\n      }; // Create all elements\n\n\n      this.stripeElements = [createAndMountStripeElement('cardNumber', '.stripe-element-card-number'), createAndMountStripeElement('cardExpiry', '.stripe-element-card-expiry'), createAndMountStripeElement('cardCvc', '.stripe-element-card-cvc')];\n    }\n    /**\n     * Unmounts all existing Stripe elements from the Stripe card payment form they are currently mounted to.\n     */\n\n  }, {\n    key: \"unmountStripeElements\",\n    value: function unmountStripeElements() {\n      this.stripeElements.forEach(function (element) {\n        return element.unmount();\n      });\n      this.stripeElements = [];\n    }\n    /**\n     * Checks the list of invalid fields for any entries and, if found, joins them to an error message, which is then\n     * displayed in the error box. If no invalid fields are found, the error box is hidden.\n     */\n\n  }, {\n    key: \"updateValidationErrors\",\n    value: function updateValidationErrors() {\n      var _this2 = this;\n\n      var errorBox = this.formEl('.stripe-payment-validation-error-box');\n      var boxContent = errorBox.find('.error-content');\n      boxContent.empty();\n\n      if (Object.keys(this.invalidFields).length > 0) {\n        // Update the error box message and make it visible\n        var listEl = $('<ul></ul>').addClass('alert--list').appendTo(boxContent);\n        Object.keys(this.invalidFields).forEach(function (key) {\n          $('<li></li>').addClass('list--entry').text(_this2.invalidFields[key]).appendTo(listEl);\n        });\n        errorBox.show();\n      } else {\n        errorBox.hide();\n      }\n    }\n    /**\n     * Adds change listeners to the card selection and card holder field as well as a submission listener on the main\n     * payment form.\n     */\n\n  }, {\n    key: \"observeForm\",\n    value: function observeForm() {\n      // Add listeners\n      this.findForm().on('submit', {\n        scope: this\n      }, this.onFormSubmission);\n      this.formEl('.stripe-saved-cards').on('change', {\n        scope: this\n      }, this.onCardSelectionChange); // Save the current value and add listener\n\n      var cardHolderElem = this.formEl('.stripe-card-holder');\n      cardHolderElem.data('oldVal', cardHolderElem.val());\n      cardHolderElem.on('propertychange keyup input paste', {\n        scope: this\n      }, this.onCardHolderChange);\n    }\n    /**\n     * Removes all validation errors for the field with the given 'fieldId' and triggers an update of the displayed\n     * validation errors.\n     *\n     * @param String fieldId\n     */\n\n  }, {\n    key: \"markFieldValid\",\n    value: function markFieldValid(fieldId) {\n      delete this.invalidFields[fieldId];\n      this.updateValidationErrors();\n    }\n    /**\n     * Determines the error message based on the given 'errorCode' and 'message' and triggers\n     * an update of the displayed validation errors.\n     *\n     * @param fieldId\n     * @param errorCode (optional) The code used to find a localised error message.\n     * @param message (optioanl) The fallback error message used in case no 'errorCode' is provided or no respective, localised description exists.\n     */\n\n  }, {\n    key: \"markFieldInvalid\",\n    value: function markFieldInvalid(fieldId, errorCode, message) {\n      this.invalidFields[fieldId] = message || 'Unknown error';\n      this.updateValidationErrors();\n    }\n    /**\n     * First validates the form and payment state and, if the main form can be submitted, does nothing further.\n     * If however the main form cannot be submitted, because no card is selected (or no token was created), a new Stripe\n     * card and token are generated using the entered card data and saved in the form, before the submission is\n     * triggered again.\n     *\n     * @param event\n     */\n\n  }, {\n    key: \"onFormSubmission\",\n    value: function onFormSubmission(event) {\n      var me = event.data.scope;\n      var form = $(this); // Check if a token/card was generated and hence the form can be submitted\n\n      if (me.selectedCard) {\n        if (!me.selectedCardChanged) {\n          return undefined;\n        }\n\n        event.preventDefault();\n\n        me._client.post(me.options.persistUrl, JSON.stringify({\n          card: me.selectedCard\n        }), function (res) {\n          var result = JSON.parse(res);\n\n          if (!result.success) {\n            return;\n          }\n\n          me.selectedCardChanged = null; // Submit the form again to finish the payment process\n\n          form.submit();\n        });\n      } // Not the currently selected payment method\n\n\n      if (!me.getActiveStripeCardForm()) {\n        return undefined;\n      } // Prevent the form from being submitted until a new Stripe token is generated and received\n\n\n      event.preventDefault(); // Check for invalid fields\n\n      if (Object.keys(me.invalidFields).length > 0) {\n        return;\n      } // Send the credit card information to Stripe\n\n\n      me.setSubmitButtonsLoading();\n      me.stripeClient.createPaymentMethod('card', me.stripeElements[0], {\n        billing_details: {\n          name: me.formEl('.stripe-card-holder').val()\n        }\n      }).then(function (result) {\n        if (result.error) {\n          // Only reset the submit buttons in case of an error, because otherwise the form is submitted again\n          // right aways and hence we want the buttons to stay disabled\n          me.resetSubmitButtons(); // Display the error\n\n          var message = result.error.message || 'Unknown error';\n          me.handleStripeError('Error: ' + message);\n        } else {\n          // Save the card information\n          var card = result.paymentMethod.card;\n          card.id = result.paymentMethod.id;\n          card.name = me.formEl('.stripe-card-holder').val();\n          me.setSelectedCard(card); // Save whether to save the credit card for future checkouts\n\n          var saveCard = me.formEl('.stripe-save-card').is(':checked');\n\n          try {\n            me._client.post(me.options.persistUrl, JSON.stringify({\n              card: card,\n              saveCard: saveCard\n            }), function (res) {\n              var result = JSON.parse(res);\n\n              if (!result.success) {\n                return;\n              } // Submit the form again to finish the payment process\n\n\n              form.submit();\n            });\n          } catch (err) {\n            /* eslint-disable no-debugger */\n            debugger;\n          }\n        }\n      });\n    }\n    /**\n     * Adds a subscriber to the card holder form field that is fired when its value is changed to validate the\n     * entered value.\n     *\n     * @param Object event\n     */\n\n  }, {\n    key: \"onCardHolderChange\",\n    value: function onCardHolderChange(event) {\n      var me = event.data.scope;\n      var elem = $(this); // Check if value has changed\n\n      if (elem.data('oldVal') === elem.val()) {\n        return;\n      }\n\n      elem.data('oldVal', elem.val()); // Validate the field\n\n      if (elem.val().trim().length === 0) {\n        elem.addClass('instyle_error has--error');\n        me.markFieldInvalid('cardHolder', 'invalid_card_holder');\n      } else {\n        elem.removeClass('instyle_error has--error');\n        me.markFieldValid('cardHolder');\n      }\n    }\n    /**\n     * Adds a change observer to the card selection field. If an existing card is selected, all form fields are hidden\n     * and the card's Stripe information is added to the form. If the 'new' option is selected, all fields made visible\n     * and the Stripe card info is removed from the form.\n     *\n     * @param Object event\n     */\n\n  }, {\n    key: \"onCardSelectionChange\",\n    value: function onCardSelectionChange(event) {\n      var me = event.data.scope;\n      var elem = $(this);\n\n      if (elem.val() === 'new') {\n        // A new, empty card was selected\n        me.setSelectedCard(null); // Make validation errors visible\n\n        me.updateValidationErrors(); // Show the save check box\n\n        me.formEl('.stripe-card-field').show();\n        me.formEl('.stripe-save-card').show().prop('checked', true);\n        return;\n      } // Find the selected card\n\n\n      for (var i = 0; i < me.allCards.length; i++) {\n        var selectedCard = me.allCards[i];\n\n        if (selectedCard.id !== elem.val()) {\n          continue;\n        } // Save the card\n\n\n        me.setSelectedCard(selectedCard); // Hide validation errors\n\n        me.formEl('.stripe-payment-validation-error-box').hide(); // Hide all card fields\n\n        me.formEl('.stripe-card-field').hide();\n        me.formEl('.stripe-save-card').hide();\n        break;\n      }\n    }\n    /**\n     * Finds both submit buttons on the page and adds the 'disabled' attribute as well as the loading indicator to each\n     * of them.\n     */\n\n  }, {\n    key: \"setSubmitButtonsLoading\",\n    value: function setSubmitButtonsLoading() {\n      // Reset the button first to prevent it from being added multiple loading indicators\n      this.resetSubmitButtons();\n      $('#confirmPaymentForm button[type=\"submit\"], .confirm--actions button[form=\"confirmPaymentForm\"]').each(function () {\n        $(this).html($(this).text() + '<div class=\"js--loading\"></div>').attr('disabled', 'disabled');\n      });\n    }\n    /**\n     * Finds both submit buttons on the page and resets them by removing the 'disabled' attribute as well as the\n     * loading indicator.\n     */\n\n  }, {\n    key: \"resetSubmitButtons\",\n    value: function resetSubmitButtons() {\n      $('#confirmPaymentForm button[type=\"submit\"], .confirm--actions button[form=\"confirmPaymentForm\"]').each(function () {\n        $(this).removeAttr('disabled').find('.js--loading').remove();\n      });\n    }\n    /**\n     * Sets the given message in the general error box and scrolls the page to make it visible.\n     *\n     * @param String message A Stripe error message.\n     */\n\n  }, {\n    key: \"handleStripeError\",\n    value: function handleStripeError(message) {\n      // Display the error information above the credit card form and scroll to its position\n      this.formEl('.stripe-payment-error-box').show().children('.error-content').html(message);\n    }\n    /**\n     * Tries to find a stripe card form for the currently active payment method. That is, if a stripe card payment\n     * method is selected, its form is returned, otherwise returns null.\n     *\n     * @return jQuery|null\n     */\n\n  }, {\n    key: \"getActiveStripeCardForm\",\n    value: function getActiveStripeCardForm() {\n      var form = $('input[id^=\"paymentMethod\"]:checked').closest('.payment-method').find('.stripe-payment-card-form');\n      return form.length > 0 ? form.first() : null;\n    }\n  }, {\n    key: \"getStripeCardForm\",\n    value: function getStripeCardForm() {\n      var form = $('input[id^=\"paymentMethod\"]').closest('.payment-method').find('.stripe-payment-card-form');\n      return form.length > 0 ? form.first() : null;\n    }\n    /**\n     * Applies a jQuery query on the DOM tree under the active stripe card form using the given selector. This method\n     * should be used when selecting any fields that are part of a Stripe card payment form. If no Stripe card form is\n     * active, an empty query result is returned.\n     *\n     * @param String selector\n     * @return jQuery\n     */\n\n  }, {\n    key: \"formEl\",\n    value: function formEl(selector) {\n      var form = this.getActiveStripeCardForm();\n      return form ? form.find(selector) : $('stripe_payment_card_not_found');\n    }\n    /**\n     * @return jQuery The main payment selection form element.\n     */\n\n  }, {\n    key: \"findForm\",\n    value: function findForm() {\n      return $('#confirmPaymentForm');\n    }\n  }]);\n\n  return StripePaymentCardSelection;\n}(src_script_plugin_system_plugin_class__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n_defineProperty(StripePaymentCardSelection, \"options\", {\n  /**\n   * @type string\n   */\n  stripePublicKey: '',\n  selectedCard: null,\n  allCards: [],\n  locale: 'en'\n});\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! /home/felix/PhpstormProjects/shopware-6/shopware-development/vendor/shopware/platform/src/Storefront/Resources/node_modules/jquery/dist/jquery.slim.js */ \"wpjq\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1RmUi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9mZWxpeC9QaHBzdG9ybVByb2plY3RzL3Nob3B3YXJlLTYvcGx1Z2lucy9TaG9wd2FyZVN0cmlwZVBheW1lbnQvc3JjL1Jlc291cmNlcy9zdG9yZWZyb250L2NhcmQtc2VsZWN0aW9uL3N0cmlwZS1wYXltZW50LmNhcmQtc2VsZWN0aW9uLmpzP2JhMTciXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLXVucmVzb2x2ZWQgKi9cblxuaW1wb3J0IEh0dHBDbGllbnQgZnJvbSAnc3JjL3NjcmlwdC9zZXJ2aWNlL2h0dHAtY2xpZW50LnNlcnZpY2UnO1xuaW1wb3J0IFBsdWdpbiBmcm9tICdzcmMvc2NyaXB0L3BsdWdpbi1zeXN0ZW0vcGx1Z2luLmNsYXNzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaXBlUGF5bWVudENhcmRTZWxlY3Rpb24gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHN0YXRpYyBvcHRpb25zID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzdHJpcGVQdWJsaWNLZXk6ICcnLFxuXG4gICAgICAgIHNlbGVjdGVkQ2FyZDogbnVsbCxcblxuICAgICAgICBhbGxDYXJkczogW10sXG5cbiAgICAgICAgbG9jYWxlOiAnZW4nLFxuICAgIH07XG5cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBuZXcgSHR0cENsaWVudCh3aW5kb3cuYWNjZXNzS2V5LCB3aW5kb3cuY29udGV4dFRva2VuKTtcbiAgICAgICAgdGhpcy5zdHJpcGVFbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmludmFsaWRGaWVsZHMgPSBbXTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFN0cmlwZVBheW1lbnRDYXJkU2VsZWN0aW9uLm9wdGlvbnMsIHRoaXMub3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIHRoaXMuYWxsQ2FyZHMgPSB0aGlzLm9wdGlvbnMuYXZhaWxhYmxlQ2FyZHM7XG5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgdGhpcy5zdHJpcGVDbGllbnQgPSBTdHJpcGUodGhpcy5vcHRpb25zLnN0cmlwZVB1YmxpY0tleSk7XG4gICAgICAgIC8vIFNhdmUgY29uZmlnXG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRDYXJkKHRoaXMub3B0aW9ucy5zZWxlY3RlZENhcmQpO1xuXG4gICAgICAgIC8vIFNldHVwIGZvcm0gb24gcGF5bWVudCBtZXRob2QgY2hhbmdlc1xuICAgICAgICBjb25zdCBwYXltZW50TWV0aG9kRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dC5wYXltZW50LW1ldGhvZC1pbnB1dCcpO1xuICAgICAgICBwYXltZW50TWV0aG9kRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBGb3JtKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zZXR1cEZvcm0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyB0aGUgZ2l2ZW4gY2FyZCBhbmQgcmVtb3ZlcyBhbGwgaGlkZGVuIFN0cmlwZSBmaWVsZHMgZnJvbSB0aGUgZm9ybS4gSWYgdGhlIGNhcmQgZXhpc3RzLCBpdHMgSUQgYXMgd2VsbCBhc1xuICAgICAqIGl0cyBlbmNvZGVkIGRhdGEgYXJlIGFkZGVkIHRvIHRoZSBmb3JtIGFzIGhpZGRlbiBmaWVsZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FyZCBBIFN0cmlwZSBjYXJkIG9iamVjdC5cbiAgICAgKi9cbiAgICBzZXRTZWxlY3RlZENhcmQoY2FyZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2FyZCA9IGNhcmQ7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ2FyZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHNldCBjYXJkICR7SlNPTi5zdHJpbmdpZnkoY2FyZCl9YCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ2FyZENoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgcGF5bWVudCBmb3JtIGJ5IGZpcnN0IHVub3VudGluZyBhbGwgU3RyaXBlIGVsZW1lbnRzIHRoYXQgbWlnaHQgYmUgYWxyZWFkeSBtb3VudGVkIHRvIHRoZSBET00gYW5kXG4gICAgICogY2xlYXJpbmcgYWxsIHZhbGlkYXRpb24gZXJyb3JzLiBUaGVuLCBpZiBhIHN0cmlwZSBjYXJkIHBheW1lbnQgbWV0aG9kIGlzIHNlbGVjdGVkLCBtb3VudHMgbmV3IFN0cmlwZSBFbGVtZW50c1xuICAgICAqIGZpZWxkcyB0byB0aGUgZm9ybSBhbmQgYWRkcyBzb21lIG9ic2VydmVycyB0byBvdGhlciBmaWVsZHMgYXMgd2VsbCBhcyB0aGUgZm9ybS5cbiAgICAgKi9cbiAgICBzZXR1cEZvcm0oKSB7XG4gICAgICAgIC8vIFJlc2V0IGZvcm1cbiAgICAgICAgdGhpcy51bm1vdW50U3RyaXBlRWxlbWVudHMoKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkRmllbGRzID0gW107XG4gICAgICAgIHRoaXMudXBkYXRlVmFsaWRhdGlvbkVycm9ycygpO1xuXG4gICAgICAgIGlmICh0aGlzLmdldEFjdGl2ZVN0cmlwZUNhcmRGb3JtKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3RyaXBlQ2FyZEZvcm0oKS5zaG93KCk7XG4gICAgICAgICAgICAvLyBNb3VudCBTdHJpcGUgZm9ybSBmaWVsZHMgYWdhaW4gdG8gdGhlIG5vdyBhY3RpdmUgZm9ybSBhbmQgYWRkIG90aGVyIG9ic2VydmVyc1xuICAgICAgICAgICAgdGhpcy5tb3VudFN0cmlwZUVsZW1lbnRzKCk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVGb3JtKCk7IC8vVE9ETzogcmVtb3ZlIGxpc3RlbmVycyBhcyB3ZWxsIG9uIGNoYW5nZVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhcmQgc2VsZWN0aW9uIG1hdGNoZXMgdGhlIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZENhcmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1FbCgnLnN0cmlwZS1zYXZlZC1jYXJkcycpLnZhbCh0aGlzLnNlbGVjdGVkQ2FyZC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvcm1FbCgnLnN0cmlwZS1zYXZlZC1jYXJkcycpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXRTdHJpcGVDYXJkRm9ybSgpLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFN0cmlwZSBFbGVtZW50cyBmaWVsZHMgZm9yIGNhcmQgbnVtYmVyLCBleHBpcnkgYW5kIENWQyBhbmQgbW91bnRzIHRoZW0gdG8gdGhlaXIgcmVzZXBjdGl2ZSBub2RlcyBpblxuICAgICAqIHRoZSBhY3RpdmUgU3RyaXBlIGNhcmQgcGF5bWVudCBmb3JtLlxuICAgICAqL1xuICAgIG1vdW50U3RyaXBlRWxlbWVudHMoKSB7XG4gICAgICAgIC8vIERlZmluZSBvcHRpb25zIHRvIGFwcGx5IHRvIGFsbCBmaWVsZHMgd2hlbiBjcmVhdGluZyB0aGVtXG4gICAgICAgIGNvbnN0IGNhcmRIb2xkZXJGaWVsZEVsID0gdGhpcy5mb3JtRWwoJy5zdHJpcGUtY2FyZC1ob2xkZXInKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGJhc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNhcmRIb2xkZXJGaWVsZEVsLmNzcygnY29sb3InKSxcbiAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogY2FyZEhvbGRlckZpZWxkRWwuY3NzKCdmb250LWZhbWlseScpLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogY2FyZEhvbGRlckZpZWxkRWwuY3NzKCdmb250LXNpemUnKSxcbiAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogY2FyZEhvbGRlckZpZWxkRWwuY3NzKCdmb250LXdlaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBjYXJkSG9sZGVyRmllbGRFbC5jc3MoJ2xpbmUtaGVpZ2h0JyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGVmaW5lIGEgY2xvc3VyZSB0byBjcmVhdGUgYWxsIGVsZW1lbnRzIHVzaW5nIHRoZSBzYW1lICdFbGVtZW50cycgaW5zdGFuY2VcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnN0cmlwZUNsaWVudC5lbGVtZW50cyh7XG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMub3B0aW9ucy5sb2NhbGUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUFuZE1vdW50U3RyaXBlRWxlbWVudCA9IGZ1bmN0aW9uKHR5cGUsIG1vdW50U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZWxlbWVudCBhbmQgYWRkIHRoZSBjaGFuZ2UgbGlzdGVuZXJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50cy5jcmVhdGUodHlwZSwgZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgICAgICAgZWxlbWVudC5vbignY2hhbmdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZXJyb3IgJiYgZXZlbnQuZXJyb3IudHlwZSA9PT0gJ3ZhbGlkYXRpb25fZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1hcmtGaWVsZEludmFsaWQodHlwZSwgZXZlbnQuZXJyb3IuY29kZSwgZXZlbnQuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUubWFya0ZpZWxkVmFsaWQodHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE1vdW50IGl0IHRvIHRoZSBET01cbiAgICAgICAgICAgIGNvbnN0IG1vdW50RWxlbWVudCA9IG1lLmZvcm1FbChtb3VudFNlbGVjdG9yKS5nZXQoMCk7XG4gICAgICAgICAgICBlbGVtZW50Lm1vdW50KG1vdW50RWxlbWVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbGwgZWxlbWVudHNcbiAgICAgICAgdGhpcy5zdHJpcGVFbGVtZW50cyA9IFtcbiAgICAgICAgICAgIGNyZWF0ZUFuZE1vdW50U3RyaXBlRWxlbWVudCgnY2FyZE51bWJlcicsICcuc3RyaXBlLWVsZW1lbnQtY2FyZC1udW1iZXInKSxcbiAgICAgICAgICAgIGNyZWF0ZUFuZE1vdW50U3RyaXBlRWxlbWVudCgnY2FyZEV4cGlyeScsICcuc3RyaXBlLWVsZW1lbnQtY2FyZC1leHBpcnknKSxcbiAgICAgICAgICAgIGNyZWF0ZUFuZE1vdW50U3RyaXBlRWxlbWVudCgnY2FyZEN2YycsICcuc3RyaXBlLWVsZW1lbnQtY2FyZC1jdmMnKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgZXhpc3RpbmcgU3RyaXBlIGVsZW1lbnRzIGZyb20gdGhlIFN0cmlwZSBjYXJkIHBheW1lbnQgZm9ybSB0aGV5IGFyZSBjdXJyZW50bHkgbW91bnRlZCB0by5cbiAgICAgKi9cbiAgICB1bm1vdW50U3RyaXBlRWxlbWVudHMoKSB7XG4gICAgICAgIHRoaXMuc3RyaXBlRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4gZWxlbWVudC51bm1vdW50KCkpO1xuICAgICAgICB0aGlzLnN0cmlwZUVsZW1lbnRzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBsaXN0IG9mIGludmFsaWQgZmllbGRzIGZvciBhbnkgZW50cmllcyBhbmQsIGlmIGZvdW5kLCBqb2lucyB0aGVtIHRvIGFuIGVycm9yIG1lc3NhZ2UsIHdoaWNoIGlzIHRoZW5cbiAgICAgKiBkaXNwbGF5ZWQgaW4gdGhlIGVycm9yIGJveC4gSWYgbm8gaW52YWxpZCBmaWVsZHMgYXJlIGZvdW5kLCB0aGUgZXJyb3IgYm94IGlzIGhpZGRlbi5cbiAgICAgKi9cbiAgICB1cGRhdGVWYWxpZGF0aW9uRXJyb3JzKCkge1xuICAgICAgICBjb25zdCBlcnJvckJveCA9IHRoaXMuZm9ybUVsKCcuc3RyaXBlLXBheW1lbnQtdmFsaWRhdGlvbi1lcnJvci1ib3gnKTtcbiAgICAgICAgY29uc3QgYm94Q29udGVudCA9IGVycm9yQm94LmZpbmQoJy5lcnJvci1jb250ZW50Jyk7XG4gICAgICAgIGJveENvbnRlbnQuZW1wdHkoKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuaW52YWxpZEZpZWxkcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBlcnJvciBib3ggbWVzc2FnZSBhbmQgbWFrZSBpdCB2aXNpYmxlXG4gICAgICAgICAgICBjb25zdCBsaXN0RWwgPSAkKCc8dWw+PC91bD4nKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnYWxlcnQtLWxpc3QnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhib3hDb250ZW50KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuaW52YWxpZEZpZWxkcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgJCgnPGxpPjwvbGk+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdsaXN0LS1lbnRyeScpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMuaW52YWxpZEZpZWxkc1trZXldKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8obGlzdEVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXJyb3JCb3guc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JCb3guaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBjaGFuZ2UgbGlzdGVuZXJzIHRvIHRoZSBjYXJkIHNlbGVjdGlvbiBhbmQgY2FyZCBob2xkZXIgZmllbGQgYXMgd2VsbCBhcyBhIHN1Ym1pc3Npb24gbGlzdGVuZXIgb24gdGhlIG1haW5cbiAgICAgKiBwYXltZW50IGZvcm0uXG4gICAgICovXG4gICAgb2JzZXJ2ZUZvcm0oKSB7XG4gICAgICAgIC8vIEFkZCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5maW5kRm9ybSgpLm9uKCdzdWJtaXQnLCB7IHNjb3BlOiB0aGlzIH0sIHRoaXMub25Gb3JtU3VibWlzc2lvbik7XG4gICAgICAgIHRoaXMuZm9ybUVsKCcuc3RyaXBlLXNhdmVkLWNhcmRzJykub24oJ2NoYW5nZScsIHsgc2NvcGU6IHRoaXMgfSwgdGhpcy5vbkNhcmRTZWxlY3Rpb25DaGFuZ2UpO1xuXG4gICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgdmFsdWUgYW5kIGFkZCBsaXN0ZW5lclxuICAgICAgICBjb25zdCBjYXJkSG9sZGVyRWxlbSA9IHRoaXMuZm9ybUVsKCcuc3RyaXBlLWNhcmQtaG9sZGVyJyk7XG4gICAgICAgIGNhcmRIb2xkZXJFbGVtLmRhdGEoJ29sZFZhbCcsIGNhcmRIb2xkZXJFbGVtLnZhbCgpKTtcbiAgICAgICAgY2FyZEhvbGRlckVsZW0ub24oJ3Byb3BlcnR5Y2hhbmdlIGtleXVwIGlucHV0IHBhc3RlJywgeyBzY29wZTogdGhpcyB9LCB0aGlzLm9uQ2FyZEhvbGRlckNoYW5nZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdmFsaWRhdGlvbiBlcnJvcnMgZm9yIHRoZSBmaWVsZCB3aXRoIHRoZSBnaXZlbiAnZmllbGRJZCcgYW5kIHRyaWdnZXJzIGFuIHVwZGF0ZSBvZiB0aGUgZGlzcGxheWVkXG4gICAgICogdmFsaWRhdGlvbiBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gU3RyaW5nIGZpZWxkSWRcbiAgICAgKi9cbiAgICBtYXJrRmllbGRWYWxpZChmaWVsZElkKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmludmFsaWRGaWVsZHNbZmllbGRJZF07XG4gICAgICAgIHRoaXMudXBkYXRlVmFsaWRhdGlvbkVycm9ycygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gdGhlIGdpdmVuICdlcnJvckNvZGUnIGFuZCAnbWVzc2FnZScgYW5kIHRyaWdnZXJzXG4gICAgICogYW4gdXBkYXRlIG9mIHRoZSBkaXNwbGF5ZWQgdmFsaWRhdGlvbiBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGRJZFxuICAgICAqIEBwYXJhbSBlcnJvckNvZGUgKG9wdGlvbmFsKSBUaGUgY29kZSB1c2VkIHRvIGZpbmQgYSBsb2NhbGlzZWQgZXJyb3IgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAob3B0aW9hbmwpIFRoZSBmYWxsYmFjayBlcnJvciBtZXNzYWdlIHVzZWQgaW4gY2FzZSBubyAnZXJyb3JDb2RlJyBpcyBwcm92aWRlZCBvciBubyByZXNwZWN0aXZlLCBsb2NhbGlzZWQgZGVzY3JpcHRpb24gZXhpc3RzLlxuICAgICAqL1xuICAgIG1hcmtGaWVsZEludmFsaWQoZmllbGRJZCwgZXJyb3JDb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZEZpZWxkc1tmaWVsZElkXSA9IG1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbGlkYXRpb25FcnJvcnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCB2YWxpZGF0ZXMgdGhlIGZvcm0gYW5kIHBheW1lbnQgc3RhdGUgYW5kLCBpZiB0aGUgbWFpbiBmb3JtIGNhbiBiZSBzdWJtaXR0ZWQsIGRvZXMgbm90aGluZyBmdXJ0aGVyLlxuICAgICAqIElmIGhvd2V2ZXIgdGhlIG1haW4gZm9ybSBjYW5ub3QgYmUgc3VibWl0dGVkLCBiZWNhdXNlIG5vIGNhcmQgaXMgc2VsZWN0ZWQgKG9yIG5vIHRva2VuIHdhcyBjcmVhdGVkKSwgYSBuZXcgU3RyaXBlXG4gICAgICogY2FyZCBhbmQgdG9rZW4gYXJlIGdlbmVyYXRlZCB1c2luZyB0aGUgZW50ZXJlZCBjYXJkIGRhdGEgYW5kIHNhdmVkIGluIHRoZSBmb3JtLCBiZWZvcmUgdGhlIHN1Ym1pc3Npb24gaXNcbiAgICAgKiB0cmlnZ2VyZWQgYWdhaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkZvcm1TdWJtaXNzaW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1lID0gZXZlbnQuZGF0YS5zY29wZTtcbiAgICAgICAgY29uc3QgZm9ybSA9ICQodGhpcyk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYSB0b2tlbi9jYXJkIHdhcyBnZW5lcmF0ZWQgYW5kIGhlbmNlIHRoZSBmb3JtIGNhbiBiZSBzdWJtaXR0ZWRcbiAgICAgICAgaWYgKG1lLnNlbGVjdGVkQ2FyZCkge1xuICAgICAgICAgICAgaWYgKCFtZS5zZWxlY3RlZENhcmRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG1lLl9jbGllbnQucG9zdChtZS5vcHRpb25zLnBlcnNpc3RVcmwsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBjYXJkOiBtZS5zZWxlY3RlZENhcmQsXG4gICAgICAgICAgICB9KSwgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UocmVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWUuc2VsZWN0ZWRDYXJkQ2hhbmdlZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBTdWJtaXQgdGhlIGZvcm0gYWdhaW4gdG8gZmluaXNoIHRoZSBwYXltZW50IHByb2Nlc3NcbiAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3QgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBwYXltZW50IG1ldGhvZFxuICAgICAgICBpZiAoIW1lLmdldEFjdGl2ZVN0cmlwZUNhcmRGb3JtKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBmb3JtIGZyb20gYmVpbmcgc3VibWl0dGVkIHVudGlsIGEgbmV3IFN0cmlwZSB0b2tlbiBpcyBnZW5lcmF0ZWQgYW5kIHJlY2VpdmVkXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludmFsaWQgZmllbGRzXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhtZS5pbnZhbGlkRmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZW5kIHRoZSBjcmVkaXQgY2FyZCBpbmZvcm1hdGlvbiB0byBTdHJpcGVcbiAgICAgICAgbWUuc2V0U3VibWl0QnV0dG9uc0xvYWRpbmcoKTtcbiAgICAgICAgbWUuc3RyaXBlQ2xpZW50LmNyZWF0ZVBheW1lbnRNZXRob2QoJ2NhcmQnLCBtZS5zdHJpcGVFbGVtZW50c1swXSwge1xuICAgICAgICAgICAgYmlsbGluZ19kZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbWUuZm9ybUVsKCcuc3RyaXBlLWNhcmQtaG9sZGVyJykudmFsKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc2V0IHRoZSBzdWJtaXQgYnV0dG9ucyBpbiBjYXNlIG9mIGFuIGVycm9yLCBiZWNhdXNlIG90aGVyd2lzZSB0aGUgZm9ybSBpcyBzdWJtaXR0ZWQgYWdhaW5cbiAgICAgICAgICAgICAgICAvLyByaWdodCBhd2F5cyBhbmQgaGVuY2Ugd2Ugd2FudCB0aGUgYnV0dG9ucyB0byBzdGF5IGRpc2FibGVkXG4gICAgICAgICAgICAgICAgbWUucmVzZXRTdWJtaXRCdXR0b25zKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBlcnJvclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXN1bHQuZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcic7XG4gICAgICAgICAgICAgICAgbWUuaGFuZGxlU3RyaXBlRXJyb3IoJ0Vycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNhcmQgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBjYXJkID0gcmVzdWx0LnBheW1lbnRNZXRob2QuY2FyZDtcbiAgICAgICAgICAgICAgICBjYXJkLmlkID0gcmVzdWx0LnBheW1lbnRNZXRob2QuaWQ7XG4gICAgICAgICAgICAgICAgY2FyZC5uYW1lID0gbWUuZm9ybUVsKCcuc3RyaXBlLWNhcmQtaG9sZGVyJykudmFsKCk7XG4gICAgICAgICAgICAgICAgbWUuc2V0U2VsZWN0ZWRDYXJkKGNhcmQpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB3aGV0aGVyIHRvIHNhdmUgdGhlIGNyZWRpdCBjYXJkIGZvciBmdXR1cmUgY2hlY2tvdXRzXG4gICAgICAgICAgICAgICAgY29uc3Qgc2F2ZUNhcmQgPSBtZS5mb3JtRWwoJy5zdHJpcGUtc2F2ZS1jYXJkJykuaXMoJzpjaGVja2VkJyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuX2NsaWVudC5wb3N0KG1lLm9wdGlvbnMucGVyc2lzdFVybCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVDYXJkLFxuICAgICAgICAgICAgICAgICAgICB9KSwgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VibWl0IHRoZSBmb3JtIGFnYWluIHRvIGZpbmlzaCB0aGUgcGF5bWVudCBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3Vic2NyaWJlciB0byB0aGUgY2FyZCBob2xkZXIgZm9ybSBmaWVsZCB0aGF0IGlzIGZpcmVkIHdoZW4gaXRzIHZhbHVlIGlzIGNoYW5nZWQgdG8gdmFsaWRhdGUgdGhlXG4gICAgICogZW50ZXJlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBPYmplY3QgZXZlbnRcbiAgICAgKi9cbiAgICBvbkNhcmRIb2xkZXJDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbWUgPSBldmVudC5kYXRhLnNjb3BlO1xuICAgICAgICBjb25zdCBlbGVtID0gJCh0aGlzKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAgICAgaWYgKGVsZW0uZGF0YSgnb2xkVmFsJykgPT09IGVsZW0udmFsKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtLmRhdGEoJ29sZFZhbCcsIGVsZW0udmFsKCkpO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBmaWVsZFxuICAgICAgICBpZiAoZWxlbS52YWwoKS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlbGVtLmFkZENsYXNzKCdpbnN0eWxlX2Vycm9yIGhhcy0tZXJyb3InKTtcbiAgICAgICAgICAgIG1lLm1hcmtGaWVsZEludmFsaWQoJ2NhcmRIb2xkZXInLCAnaW52YWxpZF9jYXJkX2hvbGRlcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVDbGFzcygnaW5zdHlsZV9lcnJvciBoYXMtLWVycm9yJyk7XG4gICAgICAgICAgICBtZS5tYXJrRmllbGRWYWxpZCgnY2FyZEhvbGRlcicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNoYW5nZSBvYnNlcnZlciB0byB0aGUgY2FyZCBzZWxlY3Rpb24gZmllbGQuIElmIGFuIGV4aXN0aW5nIGNhcmQgaXMgc2VsZWN0ZWQsIGFsbCBmb3JtIGZpZWxkcyBhcmUgaGlkZGVuXG4gICAgICogYW5kIHRoZSBjYXJkJ3MgU3RyaXBlIGluZm9ybWF0aW9uIGlzIGFkZGVkIHRvIHRoZSBmb3JtLiBJZiB0aGUgJ25ldycgb3B0aW9uIGlzIHNlbGVjdGVkLCBhbGwgZmllbGRzIG1hZGUgdmlzaWJsZVxuICAgICAqIGFuZCB0aGUgU3RyaXBlIGNhcmQgaW5mbyBpcyByZW1vdmVkIGZyb20gdGhlIGZvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gT2JqZWN0IGV2ZW50XG4gICAgICovXG4gICAgb25DYXJkU2VsZWN0aW9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1lID0gZXZlbnQuZGF0YS5zY29wZTtcbiAgICAgICAgY29uc3QgZWxlbSA9ICQodGhpcyk7XG5cbiAgICAgICAgaWYgKGVsZW0udmFsKCkgPT09ICduZXcnKSB7XG4gICAgICAgICAgICAvLyBBIG5ldywgZW1wdHkgY2FyZCB3YXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIG1lLnNldFNlbGVjdGVkQ2FyZChudWxsKTtcblxuICAgICAgICAgICAgLy8gTWFrZSB2YWxpZGF0aW9uIGVycm9ycyB2aXNpYmxlXG4gICAgICAgICAgICBtZS51cGRhdGVWYWxpZGF0aW9uRXJyb3JzKCk7XG5cbiAgICAgICAgICAgIC8vIFNob3cgdGhlIHNhdmUgY2hlY2sgYm94XG4gICAgICAgICAgICBtZS5mb3JtRWwoJy5zdHJpcGUtY2FyZC1maWVsZCcpLnNob3coKTtcbiAgICAgICAgICAgIG1lLmZvcm1FbCgnLnN0cmlwZS1zYXZlLWNhcmQnKS5zaG93KCkucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBzZWxlY3RlZCBjYXJkXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWUuYWxsQ2FyZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkQ2FyZCA9IG1lLmFsbENhcmRzW2ldO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQ2FyZC5pZCAhPT0gZWxlbS52YWwoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjYXJkXG4gICAgICAgICAgICBtZS5zZXRTZWxlY3RlZENhcmQoc2VsZWN0ZWRDYXJkKTtcblxuICAgICAgICAgICAgLy8gSGlkZSB2YWxpZGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgbWUuZm9ybUVsKCcuc3RyaXBlLXBheW1lbnQtdmFsaWRhdGlvbi1lcnJvci1ib3gnKS5oaWRlKCk7XG5cbiAgICAgICAgICAgIC8vIEhpZGUgYWxsIGNhcmQgZmllbGRzXG4gICAgICAgICAgICBtZS5mb3JtRWwoJy5zdHJpcGUtY2FyZC1maWVsZCcpLmhpZGUoKTtcbiAgICAgICAgICAgIG1lLmZvcm1FbCgnLnN0cmlwZS1zYXZlLWNhcmQnKS5oaWRlKCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYm90aCBzdWJtaXQgYnV0dG9ucyBvbiB0aGUgcGFnZSBhbmQgYWRkcyB0aGUgJ2Rpc2FibGVkJyBhdHRyaWJ1dGUgYXMgd2VsbCBhcyB0aGUgbG9hZGluZyBpbmRpY2F0b3IgdG8gZWFjaFxuICAgICAqIG9mIHRoZW0uXG4gICAgICovXG4gICAgc2V0U3VibWl0QnV0dG9uc0xvYWRpbmcoKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBidXR0b24gZmlyc3QgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGFkZGVkIG11bHRpcGxlIGxvYWRpbmcgaW5kaWNhdG9yc1xuICAgICAgICB0aGlzLnJlc2V0U3VibWl0QnV0dG9ucygpO1xuICAgICAgICAkKCcjY29uZmlybVBheW1lbnRGb3JtIGJ1dHRvblt0eXBlPVwic3VibWl0XCJdLCAuY29uZmlybS0tYWN0aW9ucyBidXR0b25bZm9ybT1cImNvbmZpcm1QYXltZW50Rm9ybVwiXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmh0bWwoJCh0aGlzKS50ZXh0KCkgKyAnPGRpdiBjbGFzcz1cImpzLS1sb2FkaW5nXCI+PC9kaXY+JykuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYm90aCBzdWJtaXQgYnV0dG9ucyBvbiB0aGUgcGFnZSBhbmQgcmVzZXRzIHRoZW0gYnkgcmVtb3ZpbmcgdGhlICdkaXNhYmxlZCcgYXR0cmlidXRlIGFzIHdlbGwgYXMgdGhlXG4gICAgICogbG9hZGluZyBpbmRpY2F0b3IuXG4gICAgICovXG4gICAgcmVzZXRTdWJtaXRCdXR0b25zKCkge1xuICAgICAgICAkKCcjY29uZmlybVBheW1lbnRGb3JtIGJ1dHRvblt0eXBlPVwic3VibWl0XCJdLCAuY29uZmlybS0tYWN0aW9ucyBidXR0b25bZm9ybT1cImNvbmZpcm1QYXltZW50Rm9ybVwiXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJykuZmluZCgnLmpzLS1sb2FkaW5nJykucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIG1lc3NhZ2UgaW4gdGhlIGdlbmVyYWwgZXJyb3IgYm94IGFuZCBzY3JvbGxzIHRoZSBwYWdlIHRvIG1ha2UgaXQgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBTdHJpbmcgbWVzc2FnZSBBIFN0cmlwZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGhhbmRsZVN0cmlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gRGlzcGxheSB0aGUgZXJyb3IgaW5mb3JtYXRpb24gYWJvdmUgdGhlIGNyZWRpdCBjYXJkIGZvcm0gYW5kIHNjcm9sbCB0byBpdHMgcG9zaXRpb25cbiAgICAgICAgdGhpcy5mb3JtRWwoJy5zdHJpcGUtcGF5bWVudC1lcnJvci1ib3gnKS5zaG93KCkuY2hpbGRyZW4oJy5lcnJvci1jb250ZW50JykuaHRtbChtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmllcyB0byBmaW5kIGEgc3RyaXBlIGNhcmQgZm9ybSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgcGF5bWVudCBtZXRob2QuIFRoYXQgaXMsIGlmIGEgc3RyaXBlIGNhcmQgcGF5bWVudFxuICAgICAqIG1ldGhvZCBpcyBzZWxlY3RlZCwgaXRzIGZvcm0gaXMgcmV0dXJuZWQsIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGpRdWVyeXxudWxsXG4gICAgICovXG4gICAgZ2V0QWN0aXZlU3RyaXBlQ2FyZEZvcm0oKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSAkKCdpbnB1dFtpZF49XCJwYXltZW50TWV0aG9kXCJdOmNoZWNrZWQnKS5jbG9zZXN0KCcucGF5bWVudC1tZXRob2QnKS5maW5kKCcuc3RyaXBlLXBheW1lbnQtY2FyZC1mb3JtJyk7XG5cbiAgICAgICAgcmV0dXJuIChmb3JtLmxlbmd0aCA+IDApID8gZm9ybS5maXJzdCgpIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXRTdHJpcGVDYXJkRm9ybSgpIHtcbiAgICAgICAgY29uc3QgZm9ybSA9ICQoJ2lucHV0W2lkXj1cInBheW1lbnRNZXRob2RcIl0nKS5jbG9zZXN0KCcucGF5bWVudC1tZXRob2QnKS5maW5kKCcuc3RyaXBlLXBheW1lbnQtY2FyZC1mb3JtJyk7XG5cbiAgICAgICAgcmV0dXJuIChmb3JtLmxlbmd0aCA+IDApID8gZm9ybS5maXJzdCgpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgalF1ZXJ5IHF1ZXJ5IG9uIHRoZSBET00gdHJlZSB1bmRlciB0aGUgYWN0aXZlIHN0cmlwZSBjYXJkIGZvcm0gdXNpbmcgdGhlIGdpdmVuIHNlbGVjdG9yLiBUaGlzIG1ldGhvZFxuICAgICAqIHNob3VsZCBiZSB1c2VkIHdoZW4gc2VsZWN0aW5nIGFueSBmaWVsZHMgdGhhdCBhcmUgcGFydCBvZiBhIFN0cmlwZSBjYXJkIHBheW1lbnQgZm9ybS4gSWYgbm8gU3RyaXBlIGNhcmQgZm9ybSBpc1xuICAgICAqIGFjdGl2ZSwgYW4gZW1wdHkgcXVlcnkgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIFN0cmluZyBzZWxlY3RvclxuICAgICAqIEByZXR1cm4galF1ZXJ5XG4gICAgICovXG4gICAgZm9ybUVsKHNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSB0aGlzLmdldEFjdGl2ZVN0cmlwZUNhcmRGb3JtKCk7XG4gICAgICAgIHJldHVybiAoZm9ybSkgPyBmb3JtLmZpbmQoc2VsZWN0b3IpIDogJCgnc3RyaXBlX3BheW1lbnRfY2FyZF9ub3RfZm91bmQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGpRdWVyeSBUaGUgbWFpbiBwYXltZW50IHNlbGVjdGlvbiBmb3JtIGVsZW1lbnQuXG4gICAgICovXG4gICAgZmluZEZvcm0oKSB7XG4gICAgICAgIHJldHVybiAkKCcjY29uZmlybVBheW1lbnRGb3JtJyk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQURBO0FBREE7QUFDQTtBQVlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBOzs7Ozs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUEvYUE7QUFDQTtBQURBO0FBRUE7OztBQUdBO0FBRUE7QUFFQTtBQUVBO0FBVkE7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:////TfR\n");

/***/ }),

/***/ "I6n5":
/*!******************************************************************************************************************************************************!*\
  !*** /home/felix/PhpstormProjects/shopware-6/plugins/ShopwareStripePayment/src/Resources/storefront/sepa-selection/stripe-payment.sepa-selection.js ***!
  \******************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return StripePaymentSepaSelection; });\n/* harmony import */ var src_script_service_http_client_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/script/service/http-client.service */ \"k8s9\");\n/* harmony import */ var src_script_plugin_system_plugin_class__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/script/plugin-system/plugin.class */ \"FGIj\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable import/no-unresolved */\n\n\n\nvar StripePaymentSepaSelection =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(StripePaymentSepaSelection, _Plugin);\n\n  function StripePaymentSepaSelection() {\n    _classCallCheck(this, StripePaymentSepaSelection);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(StripePaymentSepaSelection).apply(this, arguments));\n  }\n\n  _createClass(StripePaymentSepaSelection, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      this._client = new src_script_service_http_client_service__WEBPACK_IMPORTED_MODULE_0__[\"default\"](window.accessKey, window.contextToken);\n      this.stripeElements = [];\n      this.invalidFields = [];\n      this.options = _extends(StripePaymentSepaSelection.options, this.options || {});\n      /* eslint-disable no-undef */\n\n      this.stripeClient = Stripe(this.options.stripePublicKey); // Save config\n\n      this.setSelectedBankAccount(this.options.selectedBankAccount); // Setup form on payment method changes\n\n      var paymentMethodElements = document.querySelectorAll('input.payment-method-input');\n      paymentMethodElements.forEach(function (element) {\n        element.addEventListener('change', function () {\n          _this.setupForm();\n        });\n      });\n      this.setupForm();\n    }\n    /**\n     * Saves the given card and removes all hidden Stripe fields from the form. If the card exists, its ID as well as\n     * its encoded data are added to the form as hidden fields.\n     *\n     * @param bankAccount A Stripe card object.\n     */\n\n  }, {\n    key: \"setSelectedBankAccount\",\n    value: function setSelectedBankAccount(bankAccount) {\n      this.selectedBankAccount = bankAccount;\n\n      if (this.selectedBankAccount) {\n        console.log(\"set bankAccount \".concat(JSON.stringify(bankAccount)));\n        this.selectedBankAccountChanged = true;\n      }\n    }\n    /**\n     * Sets up the payment form by first unounting all Stripe elements that might be already mounted to the DOM and\n     * clearing all validation errors. Then, if a stripe card payment method is selected, mounts new Stripe Elements\n     * fields to the form and adds some observers to other fields as well as the form.\n     */\n\n  }, {\n    key: \"setupForm\",\n    value: function setupForm() {\n      // Reset form\n      this.unmountStripeElements();\n      this.invalidFields = [];\n      this.updateValidationErrors();\n\n      if (this.getActiveStripeSepaForm()) {\n        this.getStripeSepaForm().show(); // Mount Stripe form fields again to the now active form and add other observers\n\n        this.mountStripeElements();\n        this.observeForm(); //TODO: remove listeners as well on change\n        // Make sure the card selection matches the internal state\n\n        if (this.selectedBankAccount) {\n          this.formEl('.stripe-saved-bank-accounts').val(this.selectedBankAccount.id);\n        }\n\n        this.formEl('.stripe-saved-bank-accounts').trigger('change');\n      } else {\n        this.getStripeSepaForm().hide();\n      }\n    }\n    /**\n     * Creates the Stripe Elements fields for card number, expiry and CVC and mounts them to their resepctive nodes in\n     * the active Stripe card payment form.\n     */\n\n  }, {\n    key: \"mountStripeElements\",\n    value: function mountStripeElements() {\n      // Define options to apply to all fields when creating them\n      var accountOwnerFieldEl = this.formEl('.stripe-sepa-account-owner');\n      var defaultOptions = {\n        style: {\n          base: {\n            color: accountOwnerFieldEl.css('color'),\n            fontFamily: accountOwnerFieldEl.css('font-family'),\n            fontSize: accountOwnerFieldEl.css('font-size'),\n            fontWeight: accountOwnerFieldEl.css('font-weight'),\n            lineHeight: accountOwnerFieldEl.css('line-height')\n          }\n        }\n      }; // Define a closure to create all elements using the same 'Elements' instance\n\n      var elements = this.stripeClient.elements({\n        locale: this.options.locale\n      });\n      var me = this;\n\n      var createAndMountStripeElement = function createAndMountStripeElement(type, mountSelector) {\n        // Create the element and add the change listener\n        var options = defaultOptions;\n\n        if (type === 'iban') {\n          options = _extends(options, {\n            supportedCountries: ['SEPA'],\n            placeholderCountry: 'DE' // TODO\n\n          });\n        }\n\n        var element = elements.create(type, options);\n        element.on('change', function (event) {\n          if (event.error && event.error.type === 'validation_error') {\n            me.markFieldInvalid(type, event.error.code, event.error.message);\n          } else {\n            me.markFieldValid(type);\n          }\n        }); // Mount it to the DOM\n\n        var mountElement = me.formEl(mountSelector).get(0);\n        element.mount(mountElement);\n        return element;\n      }; // Create all elements\n\n\n      this.stripeElements = [createAndMountStripeElement('iban', '.stripe-element-sepa-iban')];\n    }\n    /**\n     * Unmounts all existing Stripe elements from the Stripe card payment form they are currently mounted to.\n     */\n\n  }, {\n    key: \"unmountStripeElements\",\n    value: function unmountStripeElements() {\n      this.stripeElements.forEach(function (element) {\n        return element.unmount();\n      });\n      this.stripeElements = [];\n    }\n    /**\n     * Checks the list of invalid fields for any entries and, if found, joins them to an error message, which is then\n     * displayed in the error box. If no invalid fields are found, the error box is hidden.\n     */\n\n  }, {\n    key: \"updateValidationErrors\",\n    value: function updateValidationErrors() {\n      var _this2 = this;\n\n      var errorBox = this.formEl('.stripe-payment-validation-error-box');\n      var boxContent = errorBox.find('.error-content');\n      boxContent.empty();\n\n      if (Object.keys(this.invalidFields).length > 0) {\n        // Update the error box message and make it visible\n        var listEl = $('<ul></ul>').addClass('alert--list').appendTo(boxContent);\n        Object.keys(this.invalidFields).forEach(function (key) {\n          $('<li></li>').addClass('list--entry').text(_this2.invalidFields[key]).appendTo(listEl);\n        });\n        errorBox.show();\n      } else {\n        errorBox.hide();\n      }\n    }\n    /**\n     * Adds change listeners to the card selection and card holder field as well as a submission listener on the main\n     * payment form.\n     */\n\n  }, {\n    key: \"observeForm\",\n    value: function observeForm() {\n      // Add listeners\n      this.findForm().on('submit', {\n        scope: this\n      }, this.onFormSubmission);\n      this.formEl('.stripe-saved-bank-accounts').on('change', {\n        scope: this\n      }, this.onBankAccountSelectionChange);\n      var me = this;\n      this.formEl('input[class^=\"stripe-sepa-\"]').each(function () {\n        // Save the current value and add listener\n        var elem = $(this);\n        elem.data('oldVal', elem.val());\n        elem.on('propertychange keyup input paste', {\n          scope: me\n        }, me.onFieldChange);\n      });\n    }\n    /**\n     * Validates the field value to not be empty. If the validation failes, the field is marked invalid.\n     *\n     * @param Event event\n     * @param boolean|undefined force\n     */\n\n  }, {\n    key: \"onFieldChange\",\n    value: function onFieldChange(event, force) {\n      var me = event.data.scope;\n      var elem = $(this);\n      var name = elem.attr('name'); // Check if value has changed, if 'force' is not set\n\n      if (!force && elem.data('oldVal') === elem.val()) {\n        return;\n      }\n\n      elem.data('oldVal', elem.val()); // Validate the field\n\n      if (elem.val().trim().length === 0) {\n        elem.addClass('instyle_error has--error');\n        me.markFieldInvalid(name, 'invalid_' + name);\n      } else {\n        elem.removeClass('instyle_error has--error');\n        me.markFieldValid(name);\n      }\n    }\n    /**\n     * Removes all validation errors for the field with the given 'fieldId' and triggers an update of the displayed\n     * validation errors.\n     *\n     * @param String fieldId\n     */\n\n  }, {\n    key: \"markFieldValid\",\n    value: function markFieldValid(fieldId) {\n      delete this.invalidFields[fieldId];\n      this.updateValidationErrors();\n    }\n    /**\n     * Determines the error message based on the given 'errorCode' and 'message' and triggers\n     * an update of the displayed validation errors.\n     *\n     * @param fieldId\n     * @param errorCode (optional) The code used to find a localised error message.\n     * @param message (optioanl) The fallback error message used in case no 'errorCode' is provided or no respective, localised description exists.\n     */\n\n  }, {\n    key: \"markFieldInvalid\",\n    value: function markFieldInvalid(fieldId, errorCode, message) {\n      this.invalidFields[fieldId] = message || 'Unknown error';\n      this.updateValidationErrors();\n    }\n    /**\n     * First validates the form and payment state and, if the main form can be submitted, does nothing further.\n     * If however the main form cannot be submitted, because no card is selected (or no token was created), a new Stripe\n     * card and token are generated using the entered card data and saved in the form, before the submission is\n     * triggered again.\n     *\n     * @param event\n     */\n\n  }, {\n    key: \"onFormSubmission\",\n    value: function onFormSubmission(event) {\n      var me = event.data.scope;\n      var form = $(this); // Check if a token/card was generated and hence the form can be submitted\n\n      if (me.selectedBankAccount) {\n        if (!me.selectedBankAccountChanged) {\n          return undefined;\n        }\n\n        event.preventDefault();\n\n        me._client.post(me.options.persistUrl, JSON.stringify({\n          selectedBankAccount: me.selectedBankAccount\n        }), function (res) {\n          var result = JSON.parse(res);\n\n          if (!result.success) {\n            return;\n          }\n\n          me.selectedBankAccountChanged = null; // Submit the form again to finish the payment process\n\n          form.submit();\n        });\n      } // Not the currently selected payment method\n\n\n      if (!me.getActiveStripeSepaForm()) {\n        return undefined;\n      } // Prevent the form from being submitted until a new Stripe token is generated and received\n\n\n      event.preventDefault(); // Check for invalid fields\n\n      if (Object.keys(me.invalidFields).length > 0) {\n        return;\n      } // Send the credit card information to Stripe\n\n\n      me.setSubmitButtonsLoading();\n      me.stripeClient.createPaymentMethod('sepa_debit', me.stripeElements[0], {\n        billing_details: {\n          name: me.formEl('.stripe-sepa-account-owner').val(),\n          email: me.formEl('.stripe-sepa-email').val()\n        }\n      }).then(function (result) {\n        if (result.error) {\n          // Only reset the submit buttons in case of an error, because otherwise the form is submitted again\n          // right aways and hence we want the buttons to stay disabled\n          me.resetSubmitButtons(); // Display the error\n\n          var message = result.error.message || 'Unknown error';\n          me.handleStripeError('Error: ' + message);\n        } else {\n          // Save the card information\n          debugger;\n          var bankAccount = result.paymentMethod.sepa_debit;\n          bankAccount.id = result.paymentMethod.id;\n          bankAccount.name = me.formEl('.stripe-sepa-account-owner').val();\n          me.setSelectedBankAccount(bankAccount);\n          var saveBankAccount = me.formEl('.stripe-save-bank-account').is(':checked');\n\n          try {\n            me._client.post(me.options.persistUrl, JSON.stringify({\n              selectedBankAccount: bankAccount,\n              saveBankAccount: saveBankAccount\n            }), function (res) {\n              var result = JSON.parse(res);\n\n              if (!result.success) {\n                return;\n              } // Submit the form again to finish the payment process\n\n\n              form.submit();\n            });\n          } catch (err) {\n            /* eslint-disable no-debugger */\n            debugger;\n          }\n        }\n      });\n    }\n    /**\n     * Adds a subscriber to the card holder form field that is fired when its value is changed to validate the\n     * entered value.\n     *\n     * @param Object event\n     */\n\n  }, {\n    key: \"onCardHolderChange\",\n    value: function onCardHolderChange(event) {\n      var me = event.data.scope;\n      var elem = $(this); // Check if value has changed\n\n      if (elem.data('oldVal') === elem.val()) {\n        return;\n      }\n\n      elem.data('oldVal', elem.val()); // Validate the field\n\n      if (elem.val().trim().length === 0) {\n        elem.addClass('instyle_error has--error');\n        me.markFieldInvalid('cardHolder', 'invalid_card_holder');\n      } else {\n        elem.removeClass('instyle_error has--error');\n        me.markFieldValid('cardHolder');\n      }\n    }\n    /**\n     * Adds a change observer to the card selection field. If an existing card is selected, all form fields are hidden\n     * and the card's Stripe information is added to the form. If the 'new' option is selected, all fields made visible\n     * and the Stripe card info is removed from the form.\n     *\n     * @param Object event\n     */\n\n  }, {\n    key: \"onBankAccountSelectionChange\",\n    value: function onBankAccountSelectionChange(event) {\n      var me = event.data.scope;\n      var elem = $(this);\n\n      if (elem.val() === 'new') {\n        // A new, empty card was selected\n        me.setSelectedBankAccount(null); // Make validation errors visible\n\n        me.updateValidationErrors(); // Show the save check box\n\n        me.formEl('.stripe-sepa-field').show();\n        me.formEl('.stripe-save-bank-account').show().prop('checked', true);\n        return;\n      } // Find the selected card\n\n\n      for (var i = 0; i < me.options.availableBankAccounts.length; i++) {\n        var selectedBankAccount = me.options.availableBankAccounts[i];\n\n        if (selectedBankAccount.id !== elem.val()) {\n          continue;\n        } // Save the card\n\n\n        me.setSelectedBankAccount(selectedBankAccount); // Hide validation errors\n\n        me.formEl('.stripe-payment-validation-error-box').hide(); // Hide all card fields\n\n        me.formEl('.stripe-sepa-field').hide();\n        me.formEl('.stripe-save-bank-account').hide();\n        break;\n      }\n    }\n    /**\n     * Finds both submit buttons on the page and adds the 'disabled' attribute as well as the loading indicator to each\n     * of them.\n     */\n\n  }, {\n    key: \"setSubmitButtonsLoading\",\n    value: function setSubmitButtonsLoading() {\n      // Reset the button first to prevent it from being added multiple loading indicators\n      this.resetSubmitButtons();\n      $('#confirmPaymentForm button[type=\"submit\"], .confirm--actions button[form=\"confirmPaymentForm\"]').each(function () {\n        $(this).html($(this).text() + '<div class=\"js--loading\"></div>').attr('disabled', 'disabled');\n      });\n    }\n    /**\n     * Finds both submit buttons on the page and resets them by removing the 'disabled' attribute as well as the\n     * loading indicator.\n     */\n\n  }, {\n    key: \"resetSubmitButtons\",\n    value: function resetSubmitButtons() {\n      $('#confirmPaymentForm button[type=\"submit\"], .confirm--actions button[form=\"confirmPaymentForm\"]').each(function () {\n        $(this).removeAttr('disabled').find('.js--loading').remove();\n      });\n    }\n    /**\n     * Sets the given message in the general error box and scrolls the page to make it visible.\n     *\n     * @param String message A Stripe error message.\n     */\n\n  }, {\n    key: \"handleStripeError\",\n    value: function handleStripeError(message) {\n      // Display the error information above the credit card form and scroll to its position\n      this.formEl('.stripe-payment-error-box').show().children('.error-content').html(message);\n    }\n    /**\n     * Tries to find a stripe card form for the currently active payment method. That is, if a stripe card payment\n     * method is selected, its form is returned, otherwise returns null.\n     *\n     * @return jQuery|null\n     */\n\n  }, {\n    key: \"getActiveStripeSepaForm\",\n    value: function getActiveStripeSepaForm() {\n      var form = $('input[id^=\"paymentMethod\"]:checked').closest('.payment-method').find('.stripe-payment-sepa-form');\n      return form.length > 0 ? form.first() : null;\n    }\n  }, {\n    key: \"getStripeSepaForm\",\n    value: function getStripeSepaForm() {\n      var form = $('input[id^=\"paymentMethod\"]').closest('.payment-method').find('.stripe-payment-sepa-form');\n      return form.length > 0 ? form.first() : null;\n    }\n    /**\n     * Applies a jQuery query on the DOM tree under the active stripe card form using the given selector. This method\n     * should be used when selecting any fields that are part of a Stripe card payment form. If no Stripe card form is\n     * active, an empty query result is returned.\n     *\n     * @param String selector\n     * @return jQuery\n     */\n\n  }, {\n    key: \"formEl\",\n    value: function formEl(selector) {\n      var form = this.getActiveStripeSepaForm();\n      return form ? form.find(selector) : $('stripe_payment_bank_account_not_found');\n    }\n    /**\n     * @return jQuery The main payment selection form element.\n     */\n\n  }, {\n    key: \"findForm\",\n    value: function findForm() {\n      return $('#confirmPaymentForm');\n    }\n  }]);\n\n  return StripePaymentSepaSelection;\n}(src_script_plugin_system_plugin_class__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n_defineProperty(StripePaymentSepaSelection, \"options\", {\n  /**\n   * @type string\n   */\n  stripePublicKey: '',\n  selectedBankAccount: null,\n  availableBankAccounts: [],\n  locale: 'en'\n});\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! /home/felix/PhpstormProjects/shopware-6/shopware-development/vendor/shopware/platform/src/Storefront/Resources/node_modules/jquery/dist/jquery.slim.js */ \"wpjq\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSTZuNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9mZWxpeC9QaHBzdG9ybVByb2plY3RzL3Nob3B3YXJlLTYvcGx1Z2lucy9TaG9wd2FyZVN0cmlwZVBheW1lbnQvc3JjL1Jlc291cmNlcy9zdG9yZWZyb250L3NlcGEtc2VsZWN0aW9uL3N0cmlwZS1wYXltZW50LnNlcGEtc2VsZWN0aW9uLmpzP2MwZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLXVucmVzb2x2ZWQgKi9cblxuaW1wb3J0IEh0dHBDbGllbnQgZnJvbSAnc3JjL3NjcmlwdC9zZXJ2aWNlL2h0dHAtY2xpZW50LnNlcnZpY2UnO1xuaW1wb3J0IFBsdWdpbiBmcm9tICdzcmMvc2NyaXB0L3BsdWdpbi1zeXN0ZW0vcGx1Z2luLmNsYXNzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaXBlUGF5bWVudFNlcGFTZWxlY3Rpb24gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHN0YXRpYyBvcHRpb25zID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzdHJpcGVQdWJsaWNLZXk6ICcnLFxuXG4gICAgICAgIHNlbGVjdGVkQmFua0FjY291bnQ6IG51bGwsXG5cbiAgICAgICAgYXZhaWxhYmxlQmFua0FjY291bnRzOiBbXSxcblxuICAgICAgICBsb2NhbGU6ICdlbicsXG4gICAgfTtcblxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IG5ldyBIdHRwQ2xpZW50KHdpbmRvdy5hY2Nlc3NLZXksIHdpbmRvdy5jb250ZXh0VG9rZW4pO1xuICAgICAgICB0aGlzLnN0cmlwZUVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuaW52YWxpZEZpZWxkcyA9IFtdO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oU3RyaXBlUGF5bWVudFNlcGFTZWxlY3Rpb24ub3B0aW9ucywgdGhpcy5vcHRpb25zIHx8IHt9KTtcblxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgICAgICB0aGlzLnN0cmlwZUNsaWVudCA9IFN0cmlwZSh0aGlzLm9wdGlvbnMuc3RyaXBlUHVibGljS2V5KTtcbiAgICAgICAgLy8gU2F2ZSBjb25maWdcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEJhbmtBY2NvdW50KHRoaXMub3B0aW9ucy5zZWxlY3RlZEJhbmtBY2NvdW50KTtcblxuICAgICAgICAvLyBTZXR1cCBmb3JtIG9uIHBheW1lbnQgbWV0aG9kIGNoYW5nZXNcbiAgICAgICAgY29uc3QgcGF5bWVudE1ldGhvZEVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQucGF5bWVudC1tZXRob2QtaW5wdXQnKTtcbiAgICAgICAgcGF5bWVudE1ldGhvZEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHVwRm9ybSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2V0dXBGb3JtKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgdGhlIGdpdmVuIGNhcmQgYW5kIHJlbW92ZXMgYWxsIGhpZGRlbiBTdHJpcGUgZmllbGRzIGZyb20gdGhlIGZvcm0uIElmIHRoZSBjYXJkIGV4aXN0cywgaXRzIElEIGFzIHdlbGwgYXNcbiAgICAgKiBpdHMgZW5jb2RlZCBkYXRhIGFyZSBhZGRlZCB0byB0aGUgZm9ybSBhcyBoaWRkZW4gZmllbGRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhbmtBY2NvdW50IEEgU3RyaXBlIGNhcmQgb2JqZWN0LlxuICAgICAqL1xuICAgIHNldFNlbGVjdGVkQmFua0FjY291bnQoYmFua0FjY291bnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEJhbmtBY2NvdW50ID0gYmFua0FjY291bnQ7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkQmFua0FjY291bnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBzZXQgYmFua0FjY291bnQgJHtKU09OLnN0cmluZ2lmeShiYW5rQWNjb3VudCl9YCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkQmFua0FjY291bnRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIHBheW1lbnQgZm9ybSBieSBmaXJzdCB1bm91bnRpbmcgYWxsIFN0cmlwZSBlbGVtZW50cyB0aGF0IG1pZ2h0IGJlIGFscmVhZHkgbW91bnRlZCB0byB0aGUgRE9NIGFuZFxuICAgICAqIGNsZWFyaW5nIGFsbCB2YWxpZGF0aW9uIGVycm9ycy4gVGhlbiwgaWYgYSBzdHJpcGUgY2FyZCBwYXltZW50IG1ldGhvZCBpcyBzZWxlY3RlZCwgbW91bnRzIG5ldyBTdHJpcGUgRWxlbWVudHNcbiAgICAgKiBmaWVsZHMgdG8gdGhlIGZvcm0gYW5kIGFkZHMgc29tZSBvYnNlcnZlcnMgdG8gb3RoZXIgZmllbGRzIGFzIHdlbGwgYXMgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc2V0dXBGb3JtKCkge1xuICAgICAgICAvLyBSZXNldCBmb3JtXG4gICAgICAgIHRoaXMudW5tb3VudFN0cmlwZUVsZW1lbnRzKCk7XG4gICAgICAgIHRoaXMuaW52YWxpZEZpZWxkcyA9IFtdO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbGlkYXRpb25FcnJvcnMoKTtcblxuICAgICAgICBpZiAodGhpcy5nZXRBY3RpdmVTdHJpcGVTZXBhRm9ybSgpKSB7XG4gICAgICAgICAgICB0aGlzLmdldFN0cmlwZVNlcGFGb3JtKCkuc2hvdygpO1xuICAgICAgICAgICAgLy8gTW91bnQgU3RyaXBlIGZvcm0gZmllbGRzIGFnYWluIHRvIHRoZSBub3cgYWN0aXZlIGZvcm0gYW5kIGFkZCBvdGhlciBvYnNlcnZlcnNcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHJpcGVFbGVtZW50cygpO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlRm9ybSgpOyAvL1RPRE86IHJlbW92ZSBsaXN0ZW5lcnMgYXMgd2VsbCBvbiBjaGFuZ2VcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjYXJkIHNlbGVjdGlvbiBtYXRjaGVzIHRoZSBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRCYW5rQWNjb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUVsKCcuc3RyaXBlLXNhdmVkLWJhbmstYWNjb3VudHMnKS52YWwodGhpcy5zZWxlY3RlZEJhbmtBY2NvdW50LmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9ybUVsKCcuc3RyaXBlLXNhdmVkLWJhbmstYWNjb3VudHMnKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3RyaXBlU2VwYUZvcm0oKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBTdHJpcGUgRWxlbWVudHMgZmllbGRzIGZvciBjYXJkIG51bWJlciwgZXhwaXJ5IGFuZCBDVkMgYW5kIG1vdW50cyB0aGVtIHRvIHRoZWlyIHJlc2VwY3RpdmUgbm9kZXMgaW5cbiAgICAgKiB0aGUgYWN0aXZlIFN0cmlwZSBjYXJkIHBheW1lbnQgZm9ybS5cbiAgICAgKi9cbiAgICBtb3VudFN0cmlwZUVsZW1lbnRzKCkge1xuICAgICAgICAvLyBEZWZpbmUgb3B0aW9ucyB0byBhcHBseSB0byBhbGwgZmllbGRzIHdoZW4gY3JlYXRpbmcgdGhlbVxuICAgICAgICBjb25zdCBhY2NvdW50T3duZXJGaWVsZEVsID0gdGhpcy5mb3JtRWwoJy5zdHJpcGUtc2VwYS1hY2NvdW50LW93bmVyJyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBiYXNlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBhY2NvdW50T3duZXJGaWVsZEVsLmNzcygnY29sb3InKSxcbiAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogYWNjb3VudE93bmVyRmllbGRFbC5jc3MoJ2ZvbnQtZmFtaWx5JyksXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBhY2NvdW50T3duZXJGaWVsZEVsLmNzcygnZm9udC1zaXplJyksXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGFjY291bnRPd25lckZpZWxkRWwuY3NzKCdmb250LXdlaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBhY2NvdW50T3duZXJGaWVsZEVsLmNzcygnbGluZS1oZWlnaHQnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZWZpbmUgYSBjbG9zdXJlIHRvIGNyZWF0ZSBhbGwgZWxlbWVudHMgdXNpbmcgdGhlIHNhbWUgJ0VsZW1lbnRzJyBpbnN0YW5jZVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuc3RyaXBlQ2xpZW50LmVsZW1lbnRzKHtcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5vcHRpb25zLmxvY2FsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgY29uc3QgY3JlYXRlQW5kTW91bnRTdHJpcGVFbGVtZW50ID0gZnVuY3Rpb24odHlwZSwgbW91bnRTZWxlY3Rvcikge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBlbGVtZW50IGFuZCBhZGQgdGhlIGNoYW5nZSBsaXN0ZW5lclxuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnaWJhbicpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZENvdW50cmllczogWydTRVBBJ10sXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyQ291bnRyeTogJ0RFJywgLy8gVE9ET1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzLmNyZWF0ZSh0eXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGVsZW1lbnQub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmVycm9yICYmIGV2ZW50LmVycm9yLnR5cGUgPT09ICd2YWxpZGF0aW9uX2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICBtZS5tYXJrRmllbGRJbnZhbGlkKHR5cGUsIGV2ZW50LmVycm9yLmNvZGUsIGV2ZW50LmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1hcmtGaWVsZFZhbGlkKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBNb3VudCBpdCB0byB0aGUgRE9NXG4gICAgICAgICAgICBjb25zdCBtb3VudEVsZW1lbnQgPSBtZS5mb3JtRWwobW91bnRTZWxlY3RvcikuZ2V0KDApO1xuICAgICAgICAgICAgZWxlbWVudC5tb3VudChtb3VudEVsZW1lbnQpO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDcmVhdGUgYWxsIGVsZW1lbnRzXG4gICAgICAgIHRoaXMuc3RyaXBlRWxlbWVudHMgPSBbXG4gICAgICAgICAgICBjcmVhdGVBbmRNb3VudFN0cmlwZUVsZW1lbnQoJ2liYW4nLCAnLnN0cmlwZS1lbGVtZW50LXNlcGEtaWJhbicpLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGFsbCBleGlzdGluZyBTdHJpcGUgZWxlbWVudHMgZnJvbSB0aGUgU3RyaXBlIGNhcmQgcGF5bWVudCBmb3JtIHRoZXkgYXJlIGN1cnJlbnRseSBtb3VudGVkIHRvLlxuICAgICAqL1xuICAgIHVubW91bnRTdHJpcGVFbGVtZW50cygpIHtcbiAgICAgICAgdGhpcy5zdHJpcGVFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiBlbGVtZW50LnVubW91bnQoKSk7XG4gICAgICAgIHRoaXMuc3RyaXBlRWxlbWVudHMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGxpc3Qgb2YgaW52YWxpZCBmaWVsZHMgZm9yIGFueSBlbnRyaWVzIGFuZCwgaWYgZm91bmQsIGpvaW5zIHRoZW0gdG8gYW4gZXJyb3IgbWVzc2FnZSwgd2hpY2ggaXMgdGhlblxuICAgICAqIGRpc3BsYXllZCBpbiB0aGUgZXJyb3IgYm94LiBJZiBubyBpbnZhbGlkIGZpZWxkcyBhcmUgZm91bmQsIHRoZSBlcnJvciBib3ggaXMgaGlkZGVuLlxuICAgICAqL1xuICAgIHVwZGF0ZVZhbGlkYXRpb25FcnJvcnMoKSB7XG4gICAgICAgIGNvbnN0IGVycm9yQm94ID0gdGhpcy5mb3JtRWwoJy5zdHJpcGUtcGF5bWVudC12YWxpZGF0aW9uLWVycm9yLWJveCcpO1xuICAgICAgICBjb25zdCBib3hDb250ZW50ID0gZXJyb3JCb3guZmluZCgnLmVycm9yLWNvbnRlbnQnKTtcbiAgICAgICAgYm94Q29udGVudC5lbXB0eSgpO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5pbnZhbGlkRmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGVycm9yIGJveCBtZXNzYWdlIGFuZCBtYWtlIGl0IHZpc2libGVcbiAgICAgICAgICAgIGNvbnN0IGxpc3RFbCA9ICQoJzx1bD48L3VsPicpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdhbGVydC0tbGlzdCcpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKGJveENvbnRlbnQpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnZhbGlkRmllbGRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAkKCc8bGk+PC9saT4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2xpc3QtLWVudHJ5JylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQodGhpcy5pbnZhbGlkRmllbGRzW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhsaXN0RWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlcnJvckJveC5zaG93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvckJveC5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGNoYW5nZSBsaXN0ZW5lcnMgdG8gdGhlIGNhcmQgc2VsZWN0aW9uIGFuZCBjYXJkIGhvbGRlciBmaWVsZCBhcyB3ZWxsIGFzIGEgc3VibWlzc2lvbiBsaXN0ZW5lciBvbiB0aGUgbWFpblxuICAgICAqIHBheW1lbnQgZm9ybS5cbiAgICAgKi9cbiAgICBvYnNlcnZlRm9ybSgpIHtcbiAgICAgICAgLy8gQWRkIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLmZpbmRGb3JtKCkub24oJ3N1Ym1pdCcsIHsgc2NvcGU6IHRoaXMgfSwgdGhpcy5vbkZvcm1TdWJtaXNzaW9uKTtcbiAgICAgICAgdGhpcy5mb3JtRWwoJy5zdHJpcGUtc2F2ZWQtYmFuay1hY2NvdW50cycpLm9uKCdjaGFuZ2UnLCB7IHNjb3BlOiB0aGlzIH0sIHRoaXMub25CYW5rQWNjb3VudFNlbGVjdGlvbkNoYW5nZSk7XG5cbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICB0aGlzLmZvcm1FbCgnaW5wdXRbY2xhc3NePVwic3RyaXBlLXNlcGEtXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHZhbHVlIGFuZCBhZGQgbGlzdGVuZXJcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSAkKHRoaXMpO1xuICAgICAgICAgICAgZWxlbS5kYXRhKCdvbGRWYWwnLCBlbGVtLnZhbCgpKTtcbiAgICAgICAgICAgIGVsZW0ub24oJ3Byb3BlcnR5Y2hhbmdlIGtleXVwIGlucHV0IHBhc3RlJywgeyBzY29wZTogbWUgfSwgbWUub25GaWVsZENoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgZmllbGQgdmFsdWUgdG8gbm90IGJlIGVtcHR5LiBJZiB0aGUgdmFsaWRhdGlvbiBmYWlsZXMsIHRoZSBmaWVsZCBpcyBtYXJrZWQgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBFdmVudCBldmVudFxuICAgICAqIEBwYXJhbSBib29sZWFufHVuZGVmaW5lZCBmb3JjZVxuICAgICAqL1xuICAgIG9uRmllbGRDaGFuZ2UoZXZlbnQsIGZvcmNlKSB7XG4gICAgICAgIGNvbnN0IG1lID0gZXZlbnQuZGF0YS5zY29wZTtcbiAgICAgICAgY29uc3QgZWxlbSA9ICQodGhpcyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBlbGVtLmF0dHIoJ25hbWUnKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB2YWx1ZSBoYXMgY2hhbmdlZCwgaWYgJ2ZvcmNlJyBpcyBub3Qgc2V0XG4gICAgICAgIGlmICghZm9yY2UgJiYgZWxlbS5kYXRhKCdvbGRWYWwnKSA9PT0gZWxlbS52YWwoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsZW0uZGF0YSgnb2xkVmFsJywgZWxlbS52YWwoKSk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGZpZWxkXG4gICAgICAgIGlmIChlbGVtLnZhbCgpLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVsZW0uYWRkQ2xhc3MoJ2luc3R5bGVfZXJyb3IgaGFzLS1lcnJvcicpO1xuICAgICAgICAgICAgbWUubWFya0ZpZWxkSW52YWxpZChuYW1lLCAoJ2ludmFsaWRfJyArIG5hbWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoJ2luc3R5bGVfZXJyb3IgaGFzLS1lcnJvcicpO1xuICAgICAgICAgICAgbWUubWFya0ZpZWxkVmFsaWQobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB2YWxpZGF0aW9uIGVycm9ycyBmb3IgdGhlIGZpZWxkIHdpdGggdGhlIGdpdmVuICdmaWVsZElkJyBhbmQgdHJpZ2dlcnMgYW4gdXBkYXRlIG9mIHRoZSBkaXNwbGF5ZWRcbiAgICAgKiB2YWxpZGF0aW9uIGVycm9ycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBTdHJpbmcgZmllbGRJZFxuICAgICAqL1xuICAgIG1hcmtGaWVsZFZhbGlkKGZpZWxkSWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaW52YWxpZEZpZWxkc1tmaWVsZElkXTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWxpZGF0aW9uRXJyb3JzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gJ2Vycm9yQ29kZScgYW5kICdtZXNzYWdlJyBhbmQgdHJpZ2dlcnNcbiAgICAgKiBhbiB1cGRhdGUgb2YgdGhlIGRpc3BsYXllZCB2YWxpZGF0aW9uIGVycm9ycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZElkXG4gICAgICogQHBhcmFtIGVycm9yQ29kZSAob3B0aW9uYWwpIFRoZSBjb2RlIHVzZWQgdG8gZmluZCBhIGxvY2FsaXNlZCBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIChvcHRpb2FubCkgVGhlIGZhbGxiYWNrIGVycm9yIG1lc3NhZ2UgdXNlZCBpbiBjYXNlIG5vICdlcnJvckNvZGUnIGlzIHByb3ZpZGVkIG9yIG5vIHJlc3BlY3RpdmUsIGxvY2FsaXNlZCBkZXNjcmlwdGlvbiBleGlzdHMuXG4gICAgICovXG4gICAgbWFya0ZpZWxkSW52YWxpZChmaWVsZElkLCBlcnJvckNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkRmllbGRzW2ZpZWxkSWRdID0gbWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcic7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsaWRhdGlvbkVycm9ycygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcnN0IHZhbGlkYXRlcyB0aGUgZm9ybSBhbmQgcGF5bWVudCBzdGF0ZSBhbmQsIGlmIHRoZSBtYWluIGZvcm0gY2FuIGJlIHN1Ym1pdHRlZCwgZG9lcyBub3RoaW5nIGZ1cnRoZXIuXG4gICAgICogSWYgaG93ZXZlciB0aGUgbWFpbiBmb3JtIGNhbm5vdCBiZSBzdWJtaXR0ZWQsIGJlY2F1c2Ugbm8gY2FyZCBpcyBzZWxlY3RlZCAob3Igbm8gdG9rZW4gd2FzIGNyZWF0ZWQpLCBhIG5ldyBTdHJpcGVcbiAgICAgKiBjYXJkIGFuZCB0b2tlbiBhcmUgZ2VuZXJhdGVkIHVzaW5nIHRoZSBlbnRlcmVkIGNhcmQgZGF0YSBhbmQgc2F2ZWQgaW4gdGhlIGZvcm0sIGJlZm9yZSB0aGUgc3VibWlzc2lvbiBpc1xuICAgICAqIHRyaWdnZXJlZCBhZ2Fpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIG9uRm9ybVN1Ym1pc3Npb24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbWUgPSBldmVudC5kYXRhLnNjb3BlO1xuICAgICAgICBjb25zdCBmb3JtID0gJCh0aGlzKTtcblxuICAgICAgICAvLyBDaGVjayBpZiBhIHRva2VuL2NhcmQgd2FzIGdlbmVyYXRlZCBhbmQgaGVuY2UgdGhlIGZvcm0gY2FuIGJlIHN1Ym1pdHRlZFxuICAgICAgICBpZiAobWUuc2VsZWN0ZWRCYW5rQWNjb3VudCkge1xuICAgICAgICAgICAgaWYgKCFtZS5zZWxlY3RlZEJhbmtBY2NvdW50Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBtZS5fY2xpZW50LnBvc3QobWUub3B0aW9ucy5wZXJzaXN0VXJsLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRCYW5rQWNjb3VudDogbWUuc2VsZWN0ZWRCYW5rQWNjb3VudCxcbiAgICAgICAgICAgIH0pLCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZS5zZWxlY3RlZEJhbmtBY2NvdW50Q2hhbmdlZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBTdWJtaXQgdGhlIGZvcm0gYWdhaW4gdG8gZmluaXNoIHRoZSBwYXltZW50IHByb2Nlc3NcbiAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3QgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBwYXltZW50IG1ldGhvZFxuICAgICAgICBpZiAoIW1lLmdldEFjdGl2ZVN0cmlwZVNlcGFGb3JtKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBmb3JtIGZyb20gYmVpbmcgc3VibWl0dGVkIHVudGlsIGEgbmV3IFN0cmlwZSB0b2tlbiBpcyBnZW5lcmF0ZWQgYW5kIHJlY2VpdmVkXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludmFsaWQgZmllbGRzXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhtZS5pbnZhbGlkRmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZW5kIHRoZSBjcmVkaXQgY2FyZCBpbmZvcm1hdGlvbiB0byBTdHJpcGVcbiAgICAgICAgbWUuc2V0U3VibWl0QnV0dG9uc0xvYWRpbmcoKTtcbiAgICAgICAgbWUuc3RyaXBlQ2xpZW50LmNyZWF0ZVBheW1lbnRNZXRob2QoJ3NlcGFfZGViaXQnLCBtZS5zdHJpcGVFbGVtZW50c1swXSwge1xuICAgICAgICAgICAgYmlsbGluZ19kZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbWUuZm9ybUVsKCcuc3RyaXBlLXNlcGEtYWNjb3VudC1vd25lcicpLnZhbCgpLFxuICAgICAgICAgICAgICAgIGVtYWlsOiBtZS5mb3JtRWwoJy5zdHJpcGUtc2VwYS1lbWFpbCcpLnZhbCgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSByZXNldCB0aGUgc3VibWl0IGJ1dHRvbnMgaW4gY2FzZSBvZiBhbiBlcnJvciwgYmVjYXVzZSBvdGhlcndpc2UgdGhlIGZvcm0gaXMgc3VibWl0dGVkIGFnYWluXG4gICAgICAgICAgICAgICAgLy8gcmlnaHQgYXdheXMgYW5kIGhlbmNlIHdlIHdhbnQgdGhlIGJ1dHRvbnMgdG8gc3RheSBkaXNhYmxlZFxuICAgICAgICAgICAgICAgIG1lLnJlc2V0U3VibWl0QnV0dG9ucygpO1xuXG4gICAgICAgICAgICAgICAgLy8gRGlzcGxheSB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVzdWx0LmVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InO1xuICAgICAgICAgICAgICAgIG1lLmhhbmRsZVN0cmlwZUVycm9yKCdFcnJvcjogJyArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBjYXJkIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFua0FjY291bnQgPSByZXN1bHQucGF5bWVudE1ldGhvZC5zZXBhX2RlYml0O1xuICAgICAgICAgICAgICAgIGJhbmtBY2NvdW50LmlkID0gcmVzdWx0LnBheW1lbnRNZXRob2QuaWQ7XG4gICAgICAgICAgICAgICAgYmFua0FjY291bnQubmFtZSA9IG1lLmZvcm1FbCgnLnN0cmlwZS1zZXBhLWFjY291bnQtb3duZXInKS52YWwoKTtcbiAgICAgICAgICAgICAgICBtZS5zZXRTZWxlY3RlZEJhbmtBY2NvdW50KGJhbmtBY2NvdW50KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNhdmVCYW5rQWNjb3VudCA9IG1lLmZvcm1FbCgnLnN0cmlwZS1zYXZlLWJhbmstYWNjb3VudCcpLmlzKCc6Y2hlY2tlZCcpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLl9jbGllbnQucG9zdChtZS5vcHRpb25zLnBlcnNpc3RVcmwsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQmFua0FjY291bnQ6IGJhbmtBY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUJhbmtBY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICB9KSwgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VibWl0IHRoZSBmb3JtIGFnYWluIHRvIGZpbmlzaCB0aGUgcGF5bWVudCBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3Vic2NyaWJlciB0byB0aGUgY2FyZCBob2xkZXIgZm9ybSBmaWVsZCB0aGF0IGlzIGZpcmVkIHdoZW4gaXRzIHZhbHVlIGlzIGNoYW5nZWQgdG8gdmFsaWRhdGUgdGhlXG4gICAgICogZW50ZXJlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBPYmplY3QgZXZlbnRcbiAgICAgKi9cbiAgICBvbkNhcmRIb2xkZXJDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbWUgPSBldmVudC5kYXRhLnNjb3BlO1xuICAgICAgICBjb25zdCBlbGVtID0gJCh0aGlzKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAgICAgaWYgKGVsZW0uZGF0YSgnb2xkVmFsJykgPT09IGVsZW0udmFsKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtLmRhdGEoJ29sZFZhbCcsIGVsZW0udmFsKCkpO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBmaWVsZFxuICAgICAgICBpZiAoZWxlbS52YWwoKS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlbGVtLmFkZENsYXNzKCdpbnN0eWxlX2Vycm9yIGhhcy0tZXJyb3InKTtcbiAgICAgICAgICAgIG1lLm1hcmtGaWVsZEludmFsaWQoJ2NhcmRIb2xkZXInLCAnaW52YWxpZF9jYXJkX2hvbGRlcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVDbGFzcygnaW5zdHlsZV9lcnJvciBoYXMtLWVycm9yJyk7XG4gICAgICAgICAgICBtZS5tYXJrRmllbGRWYWxpZCgnY2FyZEhvbGRlcicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNoYW5nZSBvYnNlcnZlciB0byB0aGUgY2FyZCBzZWxlY3Rpb24gZmllbGQuIElmIGFuIGV4aXN0aW5nIGNhcmQgaXMgc2VsZWN0ZWQsIGFsbCBmb3JtIGZpZWxkcyBhcmUgaGlkZGVuXG4gICAgICogYW5kIHRoZSBjYXJkJ3MgU3RyaXBlIGluZm9ybWF0aW9uIGlzIGFkZGVkIHRvIHRoZSBmb3JtLiBJZiB0aGUgJ25ldycgb3B0aW9uIGlzIHNlbGVjdGVkLCBhbGwgZmllbGRzIG1hZGUgdmlzaWJsZVxuICAgICAqIGFuZCB0aGUgU3RyaXBlIGNhcmQgaW5mbyBpcyByZW1vdmVkIGZyb20gdGhlIGZvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gT2JqZWN0IGV2ZW50XG4gICAgICovXG4gICAgb25CYW5rQWNjb3VudFNlbGVjdGlvbkNoYW5nZShldmVudCkge1xuICAgICAgICBjb25zdCBtZSA9IGV2ZW50LmRhdGEuc2NvcGU7XG4gICAgICAgIGNvbnN0IGVsZW0gPSAkKHRoaXMpO1xuXG4gICAgICAgIGlmIChlbGVtLnZhbCgpID09PSAnbmV3Jykge1xuICAgICAgICAgICAgLy8gQSBuZXcsIGVtcHR5IGNhcmQgd2FzIHNlbGVjdGVkXG4gICAgICAgICAgICBtZS5zZXRTZWxlY3RlZEJhbmtBY2NvdW50KG51bGwpO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHZhbGlkYXRpb24gZXJyb3JzIHZpc2libGVcbiAgICAgICAgICAgIG1lLnVwZGF0ZVZhbGlkYXRpb25FcnJvcnMoKTtcblxuICAgICAgICAgICAgLy8gU2hvdyB0aGUgc2F2ZSBjaGVjayBib3hcbiAgICAgICAgICAgIG1lLmZvcm1FbCgnLnN0cmlwZS1zZXBhLWZpZWxkJykuc2hvdygpO1xuICAgICAgICAgICAgbWUuZm9ybUVsKCcuc3RyaXBlLXNhdmUtYmFuay1hY2NvdW50Jykuc2hvdygpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCB0aGUgc2VsZWN0ZWQgY2FyZFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lLm9wdGlvbnMuYXZhaWxhYmxlQmFua0FjY291bnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEJhbmtBY2NvdW50ID0gbWUub3B0aW9ucy5hdmFpbGFibGVCYW5rQWNjb3VudHNbaV07XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRCYW5rQWNjb3VudC5pZCAhPT0gZWxlbS52YWwoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjYXJkXG4gICAgICAgICAgICBtZS5zZXRTZWxlY3RlZEJhbmtBY2NvdW50KHNlbGVjdGVkQmFua0FjY291bnQpO1xuXG4gICAgICAgICAgICAvLyBIaWRlIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgICAgICAgICBtZS5mb3JtRWwoJy5zdHJpcGUtcGF5bWVudC12YWxpZGF0aW9uLWVycm9yLWJveCcpLmhpZGUoKTtcblxuICAgICAgICAgICAgLy8gSGlkZSBhbGwgY2FyZCBmaWVsZHNcbiAgICAgICAgICAgIG1lLmZvcm1FbCgnLnN0cmlwZS1zZXBhLWZpZWxkJykuaGlkZSgpO1xuICAgICAgICAgICAgbWUuZm9ybUVsKCcuc3RyaXBlLXNhdmUtYmFuay1hY2NvdW50JykuaGlkZSgpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGJvdGggc3VibWl0IGJ1dHRvbnMgb24gdGhlIHBhZ2UgYW5kIGFkZHMgdGhlICdkaXNhYmxlZCcgYXR0cmlidXRlIGFzIHdlbGwgYXMgdGhlIGxvYWRpbmcgaW5kaWNhdG9yIHRvIGVhY2hcbiAgICAgKiBvZiB0aGVtLlxuICAgICAqL1xuICAgIHNldFN1Ym1pdEJ1dHRvbnNMb2FkaW5nKCkge1xuICAgICAgICAvLyBSZXNldCB0aGUgYnV0dG9uIGZpcnN0IHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZGRlZCBtdWx0aXBsZSBsb2FkaW5nIGluZGljYXRvcnNcbiAgICAgICAgdGhpcy5yZXNldFN1Ym1pdEJ1dHRvbnMoKTtcbiAgICAgICAgJCgnI2NvbmZpcm1QYXltZW50Rm9ybSBidXR0b25bdHlwZT1cInN1Ym1pdFwiXSwgLmNvbmZpcm0tLWFjdGlvbnMgYnV0dG9uW2Zvcm09XCJjb25maXJtUGF5bWVudEZvcm1cIl0nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5odG1sKCQodGhpcykudGV4dCgpICsgJzxkaXYgY2xhc3M9XCJqcy0tbG9hZGluZ1wiPjwvZGl2PicpLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGJvdGggc3VibWl0IGJ1dHRvbnMgb24gdGhlIHBhZ2UgYW5kIHJlc2V0cyB0aGVtIGJ5IHJlbW92aW5nIHRoZSAnZGlzYWJsZWQnIGF0dHJpYnV0ZSBhcyB3ZWxsIGFzIHRoZVxuICAgICAqIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgICAqL1xuICAgIHJlc2V0U3VibWl0QnV0dG9ucygpIHtcbiAgICAgICAgJCgnI2NvbmZpcm1QYXltZW50Rm9ybSBidXR0b25bdHlwZT1cInN1Ym1pdFwiXSwgLmNvbmZpcm0tLWFjdGlvbnMgYnV0dG9uW2Zvcm09XCJjb25maXJtUGF5bWVudEZvcm1cIl0nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpLmZpbmQoJy5qcy0tbG9hZGluZycpLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiBtZXNzYWdlIGluIHRoZSBnZW5lcmFsIGVycm9yIGJveCBhbmQgc2Nyb2xscyB0aGUgcGFnZSB0byBtYWtlIGl0IHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gU3RyaW5nIG1lc3NhZ2UgQSBTdHJpcGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBoYW5kbGVTdHJpcGVFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIC8vIERpc3BsYXkgdGhlIGVycm9yIGluZm9ybWF0aW9uIGFib3ZlIHRoZSBjcmVkaXQgY2FyZCBmb3JtIGFuZCBzY3JvbGwgdG8gaXRzIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuZm9ybUVsKCcuc3RyaXBlLXBheW1lbnQtZXJyb3ItYm94Jykuc2hvdygpLmNoaWxkcmVuKCcuZXJyb3ItY29udGVudCcpLmh0bWwobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZXMgdG8gZmluZCBhIHN0cmlwZSBjYXJkIGZvcm0gZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIHBheW1lbnQgbWV0aG9kLiBUaGF0IGlzLCBpZiBhIHN0cmlwZSBjYXJkIHBheW1lbnRcbiAgICAgKiBtZXRob2QgaXMgc2VsZWN0ZWQsIGl0cyBmb3JtIGlzIHJldHVybmVkLCBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICAgICAqXG4gICAgICogQHJldHVybiBqUXVlcnl8bnVsbFxuICAgICAqL1xuICAgIGdldEFjdGl2ZVN0cmlwZVNlcGFGb3JtKCkge1xuICAgICAgICBjb25zdCBmb3JtID0gJCgnaW5wdXRbaWRePVwicGF5bWVudE1ldGhvZFwiXTpjaGVja2VkJykuY2xvc2VzdCgnLnBheW1lbnQtbWV0aG9kJykuZmluZCgnLnN0cmlwZS1wYXltZW50LXNlcGEtZm9ybScpO1xuXG4gICAgICAgIHJldHVybiAoZm9ybS5sZW5ndGggPiAwKSA/IGZvcm0uZmlyc3QoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0U3RyaXBlU2VwYUZvcm0oKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSAkKCdpbnB1dFtpZF49XCJwYXltZW50TWV0aG9kXCJdJykuY2xvc2VzdCgnLnBheW1lbnQtbWV0aG9kJykuZmluZCgnLnN0cmlwZS1wYXltZW50LXNlcGEtZm9ybScpO1xuXG4gICAgICAgIHJldHVybiAoZm9ybS5sZW5ndGggPiAwKSA/IGZvcm0uZmlyc3QoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIGpRdWVyeSBxdWVyeSBvbiB0aGUgRE9NIHRyZWUgdW5kZXIgdGhlIGFjdGl2ZSBzdHJpcGUgY2FyZCBmb3JtIHVzaW5nIHRoZSBnaXZlbiBzZWxlY3Rvci4gVGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgYmUgdXNlZCB3aGVuIHNlbGVjdGluZyBhbnkgZmllbGRzIHRoYXQgYXJlIHBhcnQgb2YgYSBTdHJpcGUgY2FyZCBwYXltZW50IGZvcm0uIElmIG5vIFN0cmlwZSBjYXJkIGZvcm0gaXNcbiAgICAgKiBhY3RpdmUsIGFuIGVtcHR5IHF1ZXJ5IHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBTdHJpbmcgc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIGpRdWVyeVxuICAgICAqL1xuICAgIGZvcm1FbChzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBmb3JtID0gdGhpcy5nZXRBY3RpdmVTdHJpcGVTZXBhRm9ybSgpO1xuICAgICAgICByZXR1cm4gKGZvcm0pID8gZm9ybS5maW5kKHNlbGVjdG9yKSA6ICQoJ3N0cmlwZV9wYXltZW50X2JhbmtfYWNjb3VudF9ub3RfZm91bmQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGpRdWVyeSBUaGUgbWFpbiBwYXltZW50IHNlbGVjdGlvbiBmb3JtIGVsZW1lbnQuXG4gICAgICovXG4gICAgZmluZEZvcm0oKSB7XG4gICAgICAgIHJldHVybiAkKCcjY29uZmlybVBheW1lbnRGb3JtJyk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFEQTtBQURBO0FBQ0E7QUFZQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBOzs7Ozs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUdBO0FBQ0E7QUFDQTs7OztBQWxkQTtBQUNBO0FBREE7QUFFQTs7O0FBR0E7QUFFQTtBQUVBO0FBRUE7QUFWQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///I6n5\n");

/***/ }),

/***/ "qW9D":
/*!**************************************************************************************************************!*\
  !*** /home/felix/PhpstormProjects/shopware-6/plugins/ShopwareStripePayment/src/Resources/storefront/main.js ***!
  \**************************************************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _card_selection_stripe_payment_card_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./card-selection/stripe-payment.card-selection */ \"/TfR\");\n/* harmony import */ var _sepa_selection_stripe_payment_sepa_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sepa-selection/stripe-payment.sepa-selection */ \"I6n5\");\n// Import all necessary Storefront plugins and scss files\n\n // import StripePaymentPaymentIntentSubmit from './payment-intent-submit/stripe-payment.payment-intent-submit';\n// Register them via the existing PluginManager\n\nvar PluginManager = window.PluginManager;\nPluginManager.register('StripePaymentCardSelection', _card_selection_stripe_payment_card_selection__WEBPACK_IMPORTED_MODULE_0__[\"default\"], '[data-stripe-payment-card-selection]');\nPluginManager.register('StripePaymentSepaSelection', _sepa_selection_stripe_payment_sepa_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"], '[data-stripe-payment-sepa-selection]'); // PluginManager.register('StripePaymentPaymentIntentSubmit', StripePaymentPaymentIntentSubmit, '[data-stripe-payment-payment-intent-submit]');\n//Necessary for the webpack hot module reloading server\n\nif (false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicVc5RC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9mZWxpeC9QaHBzdG9ybVByb2plY3RzL3Nob3B3YXJlLTYvcGx1Z2lucy9TaG9wd2FyZVN0cmlwZVBheW1lbnQvc3JjL1Jlc291cmNlcy9zdG9yZWZyb250L21haW4uanM/MjkzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnQgYWxsIG5lY2Vzc2FyeSBTdG9yZWZyb250IHBsdWdpbnMgYW5kIHNjc3MgZmlsZXNcbmltcG9ydCBTdHJpcGVQYXltZW50Q2FyZFNlbGVjdGlvbiBmcm9tICcuL2NhcmQtc2VsZWN0aW9uL3N0cmlwZS1wYXltZW50LmNhcmQtc2VsZWN0aW9uJztcbmltcG9ydCBTdHJpcGVQYXltZW50U2VwYVNlbGVjdGlvbiBmcm9tICcuL3NlcGEtc2VsZWN0aW9uL3N0cmlwZS1wYXltZW50LnNlcGEtc2VsZWN0aW9uJztcbi8vIGltcG9ydCBTdHJpcGVQYXltZW50UGF5bWVudEludGVudFN1Ym1pdCBmcm9tICcuL3BheW1lbnQtaW50ZW50LXN1Ym1pdC9zdHJpcGUtcGF5bWVudC5wYXltZW50LWludGVudC1zdWJtaXQnO1xuXG4vLyBSZWdpc3RlciB0aGVtIHZpYSB0aGUgZXhpc3RpbmcgUGx1Z2luTWFuYWdlclxuY29uc3QgUGx1Z2luTWFuYWdlciA9IHdpbmRvdy5QbHVnaW5NYW5hZ2VyO1xuUGx1Z2luTWFuYWdlci5yZWdpc3RlcignU3RyaXBlUGF5bWVudENhcmRTZWxlY3Rpb24nLCBTdHJpcGVQYXltZW50Q2FyZFNlbGVjdGlvbiwgJ1tkYXRhLXN0cmlwZS1wYXltZW50LWNhcmQtc2VsZWN0aW9uXScpO1xuUGx1Z2luTWFuYWdlci5yZWdpc3RlcignU3RyaXBlUGF5bWVudFNlcGFTZWxlY3Rpb24nLCBTdHJpcGVQYXltZW50U2VwYVNlbGVjdGlvbiwgJ1tkYXRhLXN0cmlwZS1wYXltZW50LXNlcGEtc2VsZWN0aW9uXScpO1xuLy8gUGx1Z2luTWFuYWdlci5yZWdpc3RlcignU3RyaXBlUGF5bWVudFBheW1lbnRJbnRlbnRTdWJtaXQnLCBTdHJpcGVQYXltZW50UGF5bWVudEludGVudFN1Ym1pdCwgJ1tkYXRhLXN0cmlwZS1wYXltZW50LXBheW1lbnQtaW50ZW50LXN1Ym1pdF0nKTtcblxuXG4vL05lY2Vzc2FyeSBmb3IgdGhlIHdlYnBhY2sgaG90IG1vZHVsZSByZWxvYWRpbmcgc2VydmVyXG5pZiAobW9kdWxlLmhvdCkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KCk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///qW9D\n");

/***/ })

},[["qW9D","runtime","vendor-node","vendor-shared"]]]);