(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["stripe-payment"],{

/***/ "/TfR":
/*!******************************************************************************************************************************************************!*\
  !*** /home/felix/PhpstormProjects/shopware-6/plugins/ShopwareStripePayment/src/Resources/storefront/card-selection/stripe-payment.card-selection.js ***!
  \******************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return StripePaymentCardSelection; });\n/* harmony import */ var src_script_service_http_client_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/script/service/http-client.service */ \"k8s9\");\n/* harmony import */ var src_script_plugin_system_plugin_class__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/script/plugin-system/plugin.class */ \"FGIj\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable import/no-unresolved */\n\n\n\nvar StripePaymentCardSelection =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(StripePaymentCardSelection, _Plugin);\n\n  function StripePaymentCardSelection() {\n    _classCallCheck(this, StripePaymentCardSelection);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(StripePaymentCardSelection).apply(this, arguments));\n  }\n\n  _createClass(StripePaymentCardSelection, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      this._client = new src_script_service_http_client_service__WEBPACK_IMPORTED_MODULE_0__[\"default\"](window.accessKey, window.contextToken);\n      this.stripeElements = [];\n      this.invalidFields = [];\n      this.options = _extends(StripePaymentCardSelection.options, this.options || {});\n      /* eslint-disable no-undef */\n\n      this.stripeClient = Stripe(this.options.stripePublicKey); // Save config\n\n      this.setSelectedCard(this.options.selectedCard); // Setup form on payment method changes\n\n      var paymentMethodElements = document.querySelectorAll('input.payment-method-input');\n      paymentMethodElements.forEach(function (element) {\n        element.addEventListener('change', function () {\n          _this.setupForm();\n        });\n      });\n      this.setupForm();\n    }\n    /**\n     * Saves the given card and removes all hidden Stripe fields from the form. If the card exists, its ID as well as\n     * its encoded data are added to the form as hidden fields.\n     *\n     * @param card A Stripe card object.\n     */\n\n  }, {\n    key: \"setSelectedCard\",\n    value: function setSelectedCard(card) {\n      this.selectedCard = card;\n\n      if (this.selectedCard) {\n        console.log(\"set card \".concat(JSON.stringify(card)));\n        this.selectedCardChanged = true;\n      }\n    }\n    /**\n     * Sets up the payment form by first unounting all Stripe elements that might be already mounted to the DOM and\n     * clearing all validation errors. Then, if a stripe card payment method is selected, mounts new Stripe Elements\n     * fields to the form and adds some observers to other fields as well as the form.\n     */\n\n  }, {\n    key: \"setupForm\",\n    value: function setupForm() {\n      // Reset form\n      this.unmountStripeElements();\n      this.invalidFields = [];\n      this.updateValidationErrors();\n\n      if (this.getActiveStripeCardForm()) {\n        this.getStripeCardForm().show(); // Mount Stripe form fields again to the now active form and add other observers\n\n        this.mountStripeElements();\n        this.observeForm(); //TODO: remove listeners as well on change\n        // Make sure the card selection matches the internal state\n\n        if (this.selectedCard) {\n          this.formEl('.stripe-saved-cards').val(this.selectedCard.id);\n        }\n\n        this.formEl('.stripe-saved-cards').trigger('change');\n      } else {\n        this.removeFormListeners();\n        this.getStripeCardForm().hide();\n      }\n    }\n    /**\n     * Creates the Stripe Elements fields for card number, expiry and CVC and mounts them to their resepctive nodes in\n     * the active Stripe card payment form.\n     */\n\n  }, {\n    key: \"mountStripeElements\",\n    value: function mountStripeElements() {\n      // Define options to apply to all fields when creating them\n      var cardHolderFieldEl = this.formEl('.stripe-card-holder');\n      var defaultOptions = {\n        style: {\n          base: {\n            color: cardHolderFieldEl.css('color'),\n            fontFamily: cardHolderFieldEl.css('font-family'),\n            fontSize: cardHolderFieldEl.css('font-size'),\n            fontWeight: cardHolderFieldEl.css('font-weight'),\n            lineHeight: cardHolderFieldEl.css('line-height')\n          }\n        }\n      }; // Define a closure to create all elements using the same 'Elements' instance\n\n      var elements = this.stripeClient.elements({\n        locale: this.options.locale\n      });\n      var me = this;\n\n      var createAndMountStripeElement = function createAndMountStripeElement(type, mountSelector) {\n        // Create the element and add the change listener\n        var element = elements.create(type, defaultOptions);\n        element.on('change', function (event) {\n          if (event.error && event.error.type === 'validation_error') {\n            me.markFieldInvalid(type, event.error.code, event.error.message);\n          } else {\n            me.markFieldValid(type);\n          }\n        }); // Mount it to the DOM\n\n        var mountElement = me.formEl(mountSelector).get(0);\n        element.mount(mountElement);\n        return element;\n      }; // Create all elements\n\n\n      this.stripeElements = [createAndMountStripeElement('cardNumber', '.stripe-element-card-number'), createAndMountStripeElement('cardExpiry', '.stripe-element-card-expiry'), createAndMountStripeElement('cardCvc', '.stripe-element-card-cvc')];\n    }\n    /**\n     * Unmounts all existing Stripe elements from the Stripe card payment form they are currently mounted to.\n     */\n\n  }, {\n    key: \"unmountStripeElements\",\n    value: function unmountStripeElements() {\n      this.stripeElements.forEach(function (element) {\n        return element.unmount();\n      });\n      this.stripeElements = [];\n    }\n    /**\n     * Checks the list of invalid fields for any entries and, if found, joins them to an error message, which is then\n     * displayed in the error box. If no invalid fields are found, the error box is hidden.\n     */\n\n  }, {\n    key: \"updateValidationErrors\",\n    value: function updateValidationErrors() {\n      var _this2 = this;\n\n      var errorBox = this.formEl('.stripe-payment-validation-error-box');\n      var boxContent = errorBox.find('.error-content');\n      boxContent.empty();\n\n      if (Object.keys(this.invalidFields).length > 0) {\n        // Update the error box message and make it visible\n        var listEl = $('<ul></ul>').addClass('alert--list').appendTo(boxContent);\n        Object.keys(this.invalidFields).forEach(function (key) {\n          $('<li></li>').addClass('list--entry').text(_this2.invalidFields[key]).appendTo(listEl);\n        });\n        errorBox.show();\n      } else {\n        errorBox.hide();\n      }\n    }\n    /**\n     * Adds change listeners to the card selection and card holder field as well as a submission listener on the main\n     * payment form.\n     */\n\n  }, {\n    key: \"observeForm\",\n    value: function observeForm() {\n      // Add listeners\n      this.findForm().on('submit', {\n        scope: this\n      }, this.onFormSubmission);\n      this.formEl('.stripe-saved-cards').on('change', {\n        scope: this\n      }, this.onCardSelectionChange); // Save the current value and add listener\n\n      var cardHolderElem = this.formEl('.stripe-card-holder');\n      cardHolderElem.data('oldVal', cardHolderElem.val());\n      cardHolderElem.on('propertychange keyup input paste', {\n        scope: this\n      }, this.onCardHolderChange);\n    }\n  }, {\n    key: \"removeFormListeners\",\n    value: function removeFormListeners() {\n      this.findForm().off('submit', this.onFormSubmission);\n      this.formEl('.stripe-saved-cards').off('change', this.onCardSelectionChange);\n      this.formEl('.stripe-card-holder').off('propertychange keyup input paste', this.onCardHolderChange);\n    }\n    /**\n     * Removes all validation errors for the field with the given 'fieldId' and triggers an update of the displayed\n     * validation errors.\n     *\n     * @param String fieldId\n     */\n\n  }, {\n    key: \"markFieldValid\",\n    value: function markFieldValid(fieldId) {\n      delete this.invalidFields[fieldId];\n      this.updateValidationErrors();\n    }\n    /**\n     * Determines the error message based on the given 'errorCode' and 'message' and triggers\n     * an update of the displayed validation errors.\n     *\n     * @param fieldId\n     * @param errorCode (optional) The code used to find a localised error message.\n     * @param message (optioanl) The fallback error message used in case no 'errorCode' is provided or no respective, localised description exists.\n     */\n\n  }, {\n    key: \"markFieldInvalid\",\n    value: function markFieldInvalid(fieldId, errorCode, message) {\n      // TODO: add localized error with snippets if avail\n      this.invalidFields[fieldId] = message || 'Unknown error';\n      this.updateValidationErrors();\n    }\n    /**\n     * First validates the form and payment state and, if the main form can be submitted, does nothing further.\n     * If however the main form cannot be submitted, because no card is selected (or no token was created), a new Stripe\n     * card and token are generated using the entered card data and saved in the form, before the submission is\n     * triggered again.\n     *\n     * @param event\n     */\n\n  }, {\n    key: \"onFormSubmission\",\n    value: function onFormSubmission(event) {\n      var me = event.data.scope;\n      var form = $(this); // Not the currently selected payment method\n\n      if (!me.getActiveStripeCardForm()) {\n        return undefined;\n      } // Check if a token/card was generated and hence the form can be submitted\n\n\n      if (me.selectedCard) {\n        if (!me.selectedCardChanged) {\n          return undefined;\n        }\n\n        me.unmountStripeElements();\n        event.preventDefault();\n\n        me._client.post(me.options.persistUrl, JSON.stringify({\n          card: me.selectedCard\n        }), function (res) {\n          var result = JSON.parse(res);\n\n          if (!result.success) {\n            return;\n          }\n\n          me.selectedCardChanged = null; // Submit the form again to finish the payment process\n\n          form.submit();\n        });\n\n        return;\n      } // Prevent the form from being submitted until a new Stripe token is generated and received\n\n\n      event.preventDefault(); // Check for invalid fields\n\n      if (Object.keys(me.invalidFields).length > 0) {\n        return;\n      } // Send the credit card information to Stripe\n\n\n      me.setSubmitButtonsLoading();\n      me.stripeClient.createPaymentMethod('card', me.stripeElements[0], {\n        billing_details: {\n          name: me.formEl('.stripe-card-holder').val()\n        }\n      }).then(function (result) {\n        if (result.error) {\n          // Only reset the submit buttons in case of an error, because otherwise the form is submitted again\n          // right aways and hence we want the buttons to stay disabled\n          me.resetSubmitButtons(); // Display the error\n          // TODO: add localized error with snippets if avail\n\n          var message = result.error.message || 'Unknown error';\n          me.handleStripeError('Error: ' + message);\n        } else {\n          // Save the card information\n          var card = result.paymentMethod.card;\n          card.id = result.paymentMethod.id;\n          card.name = me.formEl('.stripe-card-holder').val();\n          me.setSelectedCard(card); // Save whether to save the credit card for future checkouts\n\n          var saveCard = me.formEl('.stripe-save-card').is(':checked');\n\n          try {\n            me._client.post(me.options.persistUrl, JSON.stringify({\n              card: card,\n              saveCard: saveCard\n            }), function (res) {\n              var result = JSON.parse(res);\n\n              if (!result.success) {\n                return;\n              } // Submit the form again to finish the payment process\n\n\n              form.submit();\n            });\n          } catch (err) {\n            /* eslint-disable no-debugger */\n            debugger;\n          }\n        }\n      });\n    }\n    /**\n     * Adds a subscriber to the card holder form field that is fired when its value is changed to validate the\n     * entered value.\n     *\n     * @param Object event\n     */\n\n  }, {\n    key: \"onCardHolderChange\",\n    value: function onCardHolderChange(event) {\n      var me = event.data.scope;\n      var elem = $(this); // Check if value has changed\n\n      if (elem.data('oldVal') === elem.val()) {\n        return;\n      }\n\n      elem.data('oldVal', elem.val()); // Validate the field\n\n      if (elem.val().trim().length === 0) {\n        elem.addClass('instyle_error has--error');\n        me.markFieldInvalid('cardHolder', 'invalid_card_holder');\n      } else {\n        elem.removeClass('instyle_error has--error');\n        me.markFieldValid('cardHolder');\n      }\n    }\n    /**\n     * Adds a change observer to the card selection field. If an existing card is selected, all form fields are hidden\n     * and the card's Stripe information is added to the form. If the 'new' option is selected, all fields made visible\n     * and the Stripe card info is removed from the form.\n     *\n     * @param Object event\n     */\n\n  }, {\n    key: \"onCardSelectionChange\",\n    value: function onCardSelectionChange(event) {\n      var me = event.data.scope;\n      var elem = $(this);\n\n      if (elem.val() === 'new') {\n        // A new, empty card was selected\n        me.setSelectedCard(null); // Make validation errors visible\n\n        me.updateValidationErrors(); // Show the save check box\n\n        me.formEl('.stripe-card-field').show();\n        me.formEl('.stripe-save-card').show().prop('checked', true);\n        return;\n      } // Find the selected card\n\n\n      for (var i = 0; i < me.options.availableCards.length; i++) {\n        var selectedCard = me.options.availableCards[i];\n\n        if (selectedCard.id !== elem.val()) {\n          continue;\n        } // Save the card\n\n\n        me.setSelectedCard(selectedCard); // Hide validation errors\n\n        me.formEl('.stripe-payment-validation-error-box').hide(); // Hide all card fields\n\n        me.formEl('.stripe-card-field').hide();\n        me.formEl('.stripe-save-card').hide();\n        break;\n      }\n    }\n    /**\n     * Finds both submit buttons on the page and adds the 'disabled' attribute as well as the loading indicator to each\n     * of them.\n     */\n\n  }, {\n    key: \"setSubmitButtonsLoading\",\n    value: function setSubmitButtonsLoading() {\n      // Reset the button first to prevent it from being added multiple loading indicators\n      this.resetSubmitButtons();\n      $('#confirmPaymentForm button[type=\"submit\"], .confirm--actions button[form=\"confirmPaymentForm\"]').each(function () {\n        $(this).html($(this).text() + '<div class=\"js--loading\"></div>').attr('disabled', 'disabled');\n      });\n    }\n    /**\n     * Finds both submit buttons on the page and resets them by removing the 'disabled' attribute as well as the\n     * loading indicator.\n     */\n\n  }, {\n    key: \"resetSubmitButtons\",\n    value: function resetSubmitButtons() {\n      $('#confirmPaymentForm button[type=\"submit\"], .confirm--actions button[form=\"confirmPaymentForm\"]').each(function () {\n        $(this).removeAttr('disabled').find('.js--loading').remove();\n      });\n    }\n    /**\n     * Sets the given message in the general error box and scrolls the page to make it visible.\n     *\n     * @param String message A Stripe error message.\n     */\n\n  }, {\n    key: \"handleStripeError\",\n    value: function handleStripeError(message) {\n      // Display the error information above the credit card form and scroll to its position\n      this.formEl('.stripe-payment-error-box').show().children('.error-content').html(message);\n    }\n    /**\n     * Tries to find a stripe card form for the currently active payment method. That is, if a stripe card payment\n     * method is selected, its form is returned, otherwise returns null.\n     *\n     * @return jQuery|null\n     */\n\n  }, {\n    key: \"getActiveStripeCardForm\",\n    value: function getActiveStripeCardForm() {\n      var form = $('input[id^=\"paymentMethod\"]:checked').closest('.payment-method').find('.stripe-payment-card-form');\n      return form.length > 0 ? form.first() : null;\n    }\n  }, {\n    key: \"getStripeCardForm\",\n    value: function getStripeCardForm() {\n      var form = $('input[id^=\"paymentMethod\"]').closest('.payment-method').find('.stripe-payment-card-form');\n      return form.length > 0 ? form.first() : null;\n    }\n    /**\n     * Applies a jQuery query on the DOM tree under the active stripe card form using the given selector. This method\n     * should be used when selecting any fields that are part of a Stripe card payment form. If no Stripe card form is\n     * active, an empty query result is returned.\n     *\n     * @param String selector\n     * @return jQuery\n     */\n\n  }, {\n    key: \"formEl\",\n    value: function formEl(selector) {\n      var form = this.getActiveStripeCardForm();\n      return form ? form.find(selector) : $('stripe_payment_card_not_found');\n    }\n    /**\n     * @return jQuery The main payment selection form element.\n     */\n\n  }, {\n    key: \"findForm\",\n    value: function findForm() {\n      return $('#confirmPaymentForm');\n    }\n  }]);\n\n  return StripePaymentCardSelection;\n}(src_script_plugin_system_plugin_class__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n_defineProperty(StripePaymentCardSelection, \"options\", {\n  /**\n   * @type string\n   */\n  stripePublicKey: '',\n  selectedCard: null,\n  availableCards: [],\n  locale: 'en'\n});\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! /home/felix/PhpstormProjects/shopware-6/shopware-development/vendor/shopware/platform/src/Storefront/Resources/node_modules/jquery/dist/jquery.slim.js */ \"wpjq\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1RmUi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9mZWxpeC9QaHBzdG9ybVByb2plY3RzL3Nob3B3YXJlLTYvcGx1Z2lucy9TaG9wd2FyZVN0cmlwZVBheW1lbnQvc3JjL1Jlc291cmNlcy9zdG9yZWZyb250L2NhcmQtc2VsZWN0aW9uL3N0cmlwZS1wYXltZW50LmNhcmQtc2VsZWN0aW9uLmpzP2JhMTciXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLXVucmVzb2x2ZWQgKi9cblxuaW1wb3J0IEh0dHBDbGllbnQgZnJvbSAnc3JjL3NjcmlwdC9zZXJ2aWNlL2h0dHAtY2xpZW50LnNlcnZpY2UnO1xuaW1wb3J0IFBsdWdpbiBmcm9tICdzcmMvc2NyaXB0L3BsdWdpbi1zeXN0ZW0vcGx1Z2luLmNsYXNzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaXBlUGF5bWVudENhcmRTZWxlY3Rpb24gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHN0YXRpYyBvcHRpb25zID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzdHJpcGVQdWJsaWNLZXk6ICcnLFxuXG4gICAgICAgIHNlbGVjdGVkQ2FyZDogbnVsbCxcblxuICAgICAgICBhdmFpbGFibGVDYXJkczogW10sXG5cbiAgICAgICAgbG9jYWxlOiAnZW4nLFxuICAgIH07XG5cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBuZXcgSHR0cENsaWVudCh3aW5kb3cuYWNjZXNzS2V5LCB3aW5kb3cuY29udGV4dFRva2VuKTtcbiAgICAgICAgdGhpcy5zdHJpcGVFbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmludmFsaWRGaWVsZHMgPSBbXTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFN0cmlwZVBheW1lbnRDYXJkU2VsZWN0aW9uLm9wdGlvbnMsIHRoaXMub3B0aW9ucyB8fCB7fSk7XG5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgdGhpcy5zdHJpcGVDbGllbnQgPSBTdHJpcGUodGhpcy5vcHRpb25zLnN0cmlwZVB1YmxpY0tleSk7XG4gICAgICAgIC8vIFNhdmUgY29uZmlnXG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRDYXJkKHRoaXMub3B0aW9ucy5zZWxlY3RlZENhcmQpO1xuXG4gICAgICAgIC8vIFNldHVwIGZvcm0gb24gcGF5bWVudCBtZXRob2QgY2hhbmdlc1xuICAgICAgICBjb25zdCBwYXltZW50TWV0aG9kRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dC5wYXltZW50LW1ldGhvZC1pbnB1dCcpO1xuICAgICAgICBwYXltZW50TWV0aG9kRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBGb3JtKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zZXR1cEZvcm0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyB0aGUgZ2l2ZW4gY2FyZCBhbmQgcmVtb3ZlcyBhbGwgaGlkZGVuIFN0cmlwZSBmaWVsZHMgZnJvbSB0aGUgZm9ybS4gSWYgdGhlIGNhcmQgZXhpc3RzLCBpdHMgSUQgYXMgd2VsbCBhc1xuICAgICAqIGl0cyBlbmNvZGVkIGRhdGEgYXJlIGFkZGVkIHRvIHRoZSBmb3JtIGFzIGhpZGRlbiBmaWVsZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FyZCBBIFN0cmlwZSBjYXJkIG9iamVjdC5cbiAgICAgKi9cbiAgICBzZXRTZWxlY3RlZENhcmQoY2FyZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2FyZCA9IGNhcmQ7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ2FyZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHNldCBjYXJkICR7SlNPTi5zdHJpbmdpZnkoY2FyZCl9YCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ2FyZENoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgcGF5bWVudCBmb3JtIGJ5IGZpcnN0IHVub3VudGluZyBhbGwgU3RyaXBlIGVsZW1lbnRzIHRoYXQgbWlnaHQgYmUgYWxyZWFkeSBtb3VudGVkIHRvIHRoZSBET00gYW5kXG4gICAgICogY2xlYXJpbmcgYWxsIHZhbGlkYXRpb24gZXJyb3JzLiBUaGVuLCBpZiBhIHN0cmlwZSBjYXJkIHBheW1lbnQgbWV0aG9kIGlzIHNlbGVjdGVkLCBtb3VudHMgbmV3IFN0cmlwZSBFbGVtZW50c1xuICAgICAqIGZpZWxkcyB0byB0aGUgZm9ybSBhbmQgYWRkcyBzb21lIG9ic2VydmVycyB0byBvdGhlciBmaWVsZHMgYXMgd2VsbCBhcyB0aGUgZm9ybS5cbiAgICAgKi9cbiAgICBzZXR1cEZvcm0oKSB7XG4gICAgICAgIC8vIFJlc2V0IGZvcm1cbiAgICAgICAgdGhpcy51bm1vdW50U3RyaXBlRWxlbWVudHMoKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkRmllbGRzID0gW107XG4gICAgICAgIHRoaXMudXBkYXRlVmFsaWRhdGlvbkVycm9ycygpO1xuXG4gICAgICAgIGlmICh0aGlzLmdldEFjdGl2ZVN0cmlwZUNhcmRGb3JtKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3RyaXBlQ2FyZEZvcm0oKS5zaG93KCk7XG4gICAgICAgICAgICAvLyBNb3VudCBTdHJpcGUgZm9ybSBmaWVsZHMgYWdhaW4gdG8gdGhlIG5vdyBhY3RpdmUgZm9ybSBhbmQgYWRkIG90aGVyIG9ic2VydmVyc1xuICAgICAgICAgICAgdGhpcy5tb3VudFN0cmlwZUVsZW1lbnRzKCk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVGb3JtKCk7IC8vVE9ETzogcmVtb3ZlIGxpc3RlbmVycyBhcyB3ZWxsIG9uIGNoYW5nZVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhcmQgc2VsZWN0aW9uIG1hdGNoZXMgdGhlIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZENhcmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1FbCgnLnN0cmlwZS1zYXZlZC1jYXJkcycpLnZhbCh0aGlzLnNlbGVjdGVkQ2FyZC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvcm1FbCgnLnN0cmlwZS1zYXZlZC1jYXJkcycpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVGb3JtTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLmdldFN0cmlwZUNhcmRGb3JtKCkuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgU3RyaXBlIEVsZW1lbnRzIGZpZWxkcyBmb3IgY2FyZCBudW1iZXIsIGV4cGlyeSBhbmQgQ1ZDIGFuZCBtb3VudHMgdGhlbSB0byB0aGVpciByZXNlcGN0aXZlIG5vZGVzIGluXG4gICAgICogdGhlIGFjdGl2ZSBTdHJpcGUgY2FyZCBwYXltZW50IGZvcm0uXG4gICAgICovXG4gICAgbW91bnRTdHJpcGVFbGVtZW50cygpIHtcbiAgICAgICAgLy8gRGVmaW5lIG9wdGlvbnMgdG8gYXBwbHkgdG8gYWxsIGZpZWxkcyB3aGVuIGNyZWF0aW5nIHRoZW1cbiAgICAgICAgY29uc3QgY2FyZEhvbGRlckZpZWxkRWwgPSB0aGlzLmZvcm1FbCgnLnN0cmlwZS1jYXJkLWhvbGRlcicpO1xuICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYmFzZToge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY2FyZEhvbGRlckZpZWxkRWwuY3NzKCdjb2xvcicpLFxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBjYXJkSG9sZGVyRmllbGRFbC5jc3MoJ2ZvbnQtZmFtaWx5JyksXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBjYXJkSG9sZGVyRmllbGRFbC5jc3MoJ2ZvbnQtc2l6ZScpLFxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBjYXJkSG9sZGVyRmllbGRFbC5jc3MoJ2ZvbnQtd2VpZ2h0JyksXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IGNhcmRIb2xkZXJGaWVsZEVsLmNzcygnbGluZS1oZWlnaHQnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZWZpbmUgYSBjbG9zdXJlIHRvIGNyZWF0ZSBhbGwgZWxlbWVudHMgdXNpbmcgdGhlIHNhbWUgJ0VsZW1lbnRzJyBpbnN0YW5jZVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuc3RyaXBlQ2xpZW50LmVsZW1lbnRzKHtcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5vcHRpb25zLmxvY2FsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgY29uc3QgY3JlYXRlQW5kTW91bnRTdHJpcGVFbGVtZW50ID0gZnVuY3Rpb24odHlwZSwgbW91bnRTZWxlY3Rvcikge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBlbGVtZW50IGFuZCBhZGQgdGhlIGNoYW5nZSBsaXN0ZW5lclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzLmNyZWF0ZSh0eXBlLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgICAgICBlbGVtZW50Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5lcnJvciAmJiBldmVudC5lcnJvci50eXBlID09PSAndmFsaWRhdGlvbl9lcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUubWFya0ZpZWxkSW52YWxpZCh0eXBlLCBldmVudC5lcnJvci5jb2RlLCBldmVudC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5tYXJrRmllbGRWYWxpZCh0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTW91bnQgaXQgdG8gdGhlIERPTVxuICAgICAgICAgICAgY29uc3QgbW91bnRFbGVtZW50ID0gbWUuZm9ybUVsKG1vdW50U2VsZWN0b3IpLmdldCgwKTtcbiAgICAgICAgICAgIGVsZW1lbnQubW91bnQobW91bnRFbGVtZW50KTtcblxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBlbGVtZW50c1xuICAgICAgICB0aGlzLnN0cmlwZUVsZW1lbnRzID0gW1xuICAgICAgICAgICAgY3JlYXRlQW5kTW91bnRTdHJpcGVFbGVtZW50KCdjYXJkTnVtYmVyJywgJy5zdHJpcGUtZWxlbWVudC1jYXJkLW51bWJlcicpLFxuICAgICAgICAgICAgY3JlYXRlQW5kTW91bnRTdHJpcGVFbGVtZW50KCdjYXJkRXhwaXJ5JywgJy5zdHJpcGUtZWxlbWVudC1jYXJkLWV4cGlyeScpLFxuICAgICAgICAgICAgY3JlYXRlQW5kTW91bnRTdHJpcGVFbGVtZW50KCdjYXJkQ3ZjJywgJy5zdHJpcGUtZWxlbWVudC1jYXJkLWN2YycpLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGFsbCBleGlzdGluZyBTdHJpcGUgZWxlbWVudHMgZnJvbSB0aGUgU3RyaXBlIGNhcmQgcGF5bWVudCBmb3JtIHRoZXkgYXJlIGN1cnJlbnRseSBtb3VudGVkIHRvLlxuICAgICAqL1xuICAgIHVubW91bnRTdHJpcGVFbGVtZW50cygpIHtcbiAgICAgICAgdGhpcy5zdHJpcGVFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiBlbGVtZW50LnVubW91bnQoKSk7XG4gICAgICAgIHRoaXMuc3RyaXBlRWxlbWVudHMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGxpc3Qgb2YgaW52YWxpZCBmaWVsZHMgZm9yIGFueSBlbnRyaWVzIGFuZCwgaWYgZm91bmQsIGpvaW5zIHRoZW0gdG8gYW4gZXJyb3IgbWVzc2FnZSwgd2hpY2ggaXMgdGhlblxuICAgICAqIGRpc3BsYXllZCBpbiB0aGUgZXJyb3IgYm94LiBJZiBubyBpbnZhbGlkIGZpZWxkcyBhcmUgZm91bmQsIHRoZSBlcnJvciBib3ggaXMgaGlkZGVuLlxuICAgICAqL1xuICAgIHVwZGF0ZVZhbGlkYXRpb25FcnJvcnMoKSB7XG4gICAgICAgIGNvbnN0IGVycm9yQm94ID0gdGhpcy5mb3JtRWwoJy5zdHJpcGUtcGF5bWVudC12YWxpZGF0aW9uLWVycm9yLWJveCcpO1xuICAgICAgICBjb25zdCBib3hDb250ZW50ID0gZXJyb3JCb3guZmluZCgnLmVycm9yLWNvbnRlbnQnKTtcbiAgICAgICAgYm94Q29udGVudC5lbXB0eSgpO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5pbnZhbGlkRmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGVycm9yIGJveCBtZXNzYWdlIGFuZCBtYWtlIGl0IHZpc2libGVcbiAgICAgICAgICAgIGNvbnN0IGxpc3RFbCA9ICQoJzx1bD48L3VsPicpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdhbGVydC0tbGlzdCcpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKGJveENvbnRlbnQpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnZhbGlkRmllbGRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAkKCc8bGk+PC9saT4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2xpc3QtLWVudHJ5JylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQodGhpcy5pbnZhbGlkRmllbGRzW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhsaXN0RWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlcnJvckJveC5zaG93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvckJveC5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGNoYW5nZSBsaXN0ZW5lcnMgdG8gdGhlIGNhcmQgc2VsZWN0aW9uIGFuZCBjYXJkIGhvbGRlciBmaWVsZCBhcyB3ZWxsIGFzIGEgc3VibWlzc2lvbiBsaXN0ZW5lciBvbiB0aGUgbWFpblxuICAgICAqIHBheW1lbnQgZm9ybS5cbiAgICAgKi9cbiAgICBvYnNlcnZlRm9ybSgpIHtcbiAgICAgICAgLy8gQWRkIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLmZpbmRGb3JtKCkub24oJ3N1Ym1pdCcsIHsgc2NvcGU6IHRoaXMgfSwgdGhpcy5vbkZvcm1TdWJtaXNzaW9uKTtcbiAgICAgICAgdGhpcy5mb3JtRWwoJy5zdHJpcGUtc2F2ZWQtY2FyZHMnKS5vbignY2hhbmdlJywgeyBzY29wZTogdGhpcyB9LCB0aGlzLm9uQ2FyZFNlbGVjdGlvbkNoYW5nZSk7XG5cbiAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCB2YWx1ZSBhbmQgYWRkIGxpc3RlbmVyXG4gICAgICAgIGNvbnN0IGNhcmRIb2xkZXJFbGVtID0gdGhpcy5mb3JtRWwoJy5zdHJpcGUtY2FyZC1ob2xkZXInKTtcbiAgICAgICAgY2FyZEhvbGRlckVsZW0uZGF0YSgnb2xkVmFsJywgY2FyZEhvbGRlckVsZW0udmFsKCkpO1xuICAgICAgICBjYXJkSG9sZGVyRWxlbS5vbigncHJvcGVydHljaGFuZ2Uga2V5dXAgaW5wdXQgcGFzdGUnLCB7IHNjb3BlOiB0aGlzIH0sIHRoaXMub25DYXJkSG9sZGVyQ2hhbmdlKTtcbiAgICB9XG5cbiAgICByZW1vdmVGb3JtTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmZpbmRGb3JtKCkub2ZmKCdzdWJtaXQnLCB0aGlzLm9uRm9ybVN1Ym1pc3Npb24pO1xuICAgICAgICB0aGlzLmZvcm1FbCgnLnN0cmlwZS1zYXZlZC1jYXJkcycpLm9mZignY2hhbmdlJywgdGhpcy5vbkNhcmRTZWxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICB0aGlzLmZvcm1FbCgnLnN0cmlwZS1jYXJkLWhvbGRlcicpLm9mZigncHJvcGVydHljaGFuZ2Uga2V5dXAgaW5wdXQgcGFzdGUnLCB0aGlzLm9uQ2FyZEhvbGRlckNoYW5nZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdmFsaWRhdGlvbiBlcnJvcnMgZm9yIHRoZSBmaWVsZCB3aXRoIHRoZSBnaXZlbiAnZmllbGRJZCcgYW5kIHRyaWdnZXJzIGFuIHVwZGF0ZSBvZiB0aGUgZGlzcGxheWVkXG4gICAgICogdmFsaWRhdGlvbiBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gU3RyaW5nIGZpZWxkSWRcbiAgICAgKi9cbiAgICBtYXJrRmllbGRWYWxpZChmaWVsZElkKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmludmFsaWRGaWVsZHNbZmllbGRJZF07XG4gICAgICAgIHRoaXMudXBkYXRlVmFsaWRhdGlvbkVycm9ycygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gdGhlIGdpdmVuICdlcnJvckNvZGUnIGFuZCAnbWVzc2FnZScgYW5kIHRyaWdnZXJzXG4gICAgICogYW4gdXBkYXRlIG9mIHRoZSBkaXNwbGF5ZWQgdmFsaWRhdGlvbiBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGRJZFxuICAgICAqIEBwYXJhbSBlcnJvckNvZGUgKG9wdGlvbmFsKSBUaGUgY29kZSB1c2VkIHRvIGZpbmQgYSBsb2NhbGlzZWQgZXJyb3IgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAob3B0aW9hbmwpIFRoZSBmYWxsYmFjayBlcnJvciBtZXNzYWdlIHVzZWQgaW4gY2FzZSBubyAnZXJyb3JDb2RlJyBpcyBwcm92aWRlZCBvciBubyByZXNwZWN0aXZlLCBsb2NhbGlzZWQgZGVzY3JpcHRpb24gZXhpc3RzLlxuICAgICAqL1xuICAgIG1hcmtGaWVsZEludmFsaWQoZmllbGRJZCwgZXJyb3JDb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIC8vIFRPRE86IGFkZCBsb2NhbGl6ZWQgZXJyb3Igd2l0aCBzbmlwcGV0cyBpZiBhdmFpbFxuICAgICAgICB0aGlzLmludmFsaWRGaWVsZHNbZmllbGRJZF0gPSBtZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJztcbiAgICAgICAgdGhpcy51cGRhdGVWYWxpZGF0aW9uRXJyb3JzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyc3QgdmFsaWRhdGVzIHRoZSBmb3JtIGFuZCBwYXltZW50IHN0YXRlIGFuZCwgaWYgdGhlIG1haW4gZm9ybSBjYW4gYmUgc3VibWl0dGVkLCBkb2VzIG5vdGhpbmcgZnVydGhlci5cbiAgICAgKiBJZiBob3dldmVyIHRoZSBtYWluIGZvcm0gY2Fubm90IGJlIHN1Ym1pdHRlZCwgYmVjYXVzZSBubyBjYXJkIGlzIHNlbGVjdGVkIChvciBubyB0b2tlbiB3YXMgY3JlYXRlZCksIGEgbmV3IFN0cmlwZVxuICAgICAqIGNhcmQgYW5kIHRva2VuIGFyZSBnZW5lcmF0ZWQgdXNpbmcgdGhlIGVudGVyZWQgY2FyZCBkYXRhIGFuZCBzYXZlZCBpbiB0aGUgZm9ybSwgYmVmb3JlIHRoZSBzdWJtaXNzaW9uIGlzXG4gICAgICogdHJpZ2dlcmVkIGFnYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgb25Gb3JtU3VibWlzc2lvbihldmVudCkge1xuICAgICAgICBjb25zdCBtZSA9IGV2ZW50LmRhdGEuc2NvcGU7XG4gICAgICAgIGNvbnN0IGZvcm0gPSAkKHRoaXMpO1xuXG4gICAgICAgIC8vIE5vdCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBheW1lbnQgbWV0aG9kXG4gICAgICAgIGlmICghbWUuZ2V0QWN0aXZlU3RyaXBlQ2FyZEZvcm0oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGEgdG9rZW4vY2FyZCB3YXMgZ2VuZXJhdGVkIGFuZCBoZW5jZSB0aGUgZm9ybSBjYW4gYmUgc3VibWl0dGVkXG4gICAgICAgIGlmIChtZS5zZWxlY3RlZENhcmQpIHtcbiAgICAgICAgICAgIGlmICghbWUuc2VsZWN0ZWRDYXJkQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnVubW91bnRTdHJpcGVFbGVtZW50cygpO1xuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbWUuX2NsaWVudC5wb3N0KG1lLm9wdGlvbnMucGVyc2lzdFVybCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGNhcmQ6IG1lLnNlbGVjdGVkQ2FyZCxcbiAgICAgICAgICAgIH0pLCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZS5zZWxlY3RlZENhcmRDaGFuZ2VkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIFN1Ym1pdCB0aGUgZm9ybSBhZ2FpbiB0byBmaW5pc2ggdGhlIHBheW1lbnQgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJldmVudCB0aGUgZm9ybSBmcm9tIGJlaW5nIHN1Ym1pdHRlZCB1bnRpbCBhIG5ldyBTdHJpcGUgdG9rZW4gaXMgZ2VuZXJhdGVkIGFuZCByZWNlaXZlZFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIGZpZWxkc1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWUuaW52YWxpZEZpZWxkcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VuZCB0aGUgY3JlZGl0IGNhcmQgaW5mb3JtYXRpb24gdG8gU3RyaXBlXG4gICAgICAgIG1lLnNldFN1Ym1pdEJ1dHRvbnNMb2FkaW5nKCk7XG4gICAgICAgIG1lLnN0cmlwZUNsaWVudC5jcmVhdGVQYXltZW50TWV0aG9kKCdjYXJkJywgbWUuc3RyaXBlRWxlbWVudHNbMF0sIHtcbiAgICAgICAgICAgIGJpbGxpbmdfZGV0YWlsczoge1xuICAgICAgICAgICAgICAgIG5hbWU6IG1lLmZvcm1FbCgnLnN0cmlwZS1jYXJkLWhvbGRlcicpLnZhbCgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSByZXNldCB0aGUgc3VibWl0IGJ1dHRvbnMgaW4gY2FzZSBvZiBhbiBlcnJvciwgYmVjYXVzZSBvdGhlcndpc2UgdGhlIGZvcm0gaXMgc3VibWl0dGVkIGFnYWluXG4gICAgICAgICAgICAgICAgLy8gcmlnaHQgYXdheXMgYW5kIGhlbmNlIHdlIHdhbnQgdGhlIGJ1dHRvbnMgdG8gc3RheSBkaXNhYmxlZFxuICAgICAgICAgICAgICAgIG1lLnJlc2V0U3VibWl0QnV0dG9ucygpO1xuXG4gICAgICAgICAgICAgICAgLy8gRGlzcGxheSB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhZGQgbG9jYWxpemVkIGVycm9yIHdpdGggc25pcHBldHMgaWYgYXZhaWxcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVzdWx0LmVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InO1xuICAgICAgICAgICAgICAgIG1lLmhhbmRsZVN0cmlwZUVycm9yKCdFcnJvcjogJyArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBjYXJkIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgY2FyZCA9IHJlc3VsdC5wYXltZW50TWV0aG9kLmNhcmQ7XG4gICAgICAgICAgICAgICAgY2FyZC5pZCA9IHJlc3VsdC5wYXltZW50TWV0aG9kLmlkO1xuICAgICAgICAgICAgICAgIGNhcmQubmFtZSA9IG1lLmZvcm1FbCgnLnN0cmlwZS1jYXJkLWhvbGRlcicpLnZhbCgpO1xuICAgICAgICAgICAgICAgIG1lLnNldFNlbGVjdGVkQ2FyZChjYXJkKTtcblxuICAgICAgICAgICAgICAgIC8vIFNhdmUgd2hldGhlciB0byBzYXZlIHRoZSBjcmVkaXQgY2FyZCBmb3IgZnV0dXJlIGNoZWNrb3V0c1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhdmVDYXJkID0gbWUuZm9ybUVsKCcuc3RyaXBlLXNhdmUtY2FyZCcpLmlzKCc6Y2hlY2tlZCcpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLl9jbGllbnQucG9zdChtZS5vcHRpb25zLnBlcnNpc3RVcmwsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlQ2FyZCxcbiAgICAgICAgICAgICAgICAgICAgfSksIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Ym1pdCB0aGUgZm9ybSBhZ2FpbiB0byBmaW5pc2ggdGhlIHBheW1lbnQgcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN1YnNjcmliZXIgdG8gdGhlIGNhcmQgaG9sZGVyIGZvcm0gZmllbGQgdGhhdCBpcyBmaXJlZCB3aGVuIGl0cyB2YWx1ZSBpcyBjaGFuZ2VkIHRvIHZhbGlkYXRlIHRoZVxuICAgICAqIGVudGVyZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gT2JqZWN0IGV2ZW50XG4gICAgICovXG4gICAgb25DYXJkSG9sZGVyQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1lID0gZXZlbnQuZGF0YS5zY29wZTtcbiAgICAgICAgY29uc3QgZWxlbSA9ICQodGhpcyk7XG4gICAgICAgIC8vIENoZWNrIGlmIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgICAgIGlmIChlbGVtLmRhdGEoJ29sZFZhbCcpID09PSBlbGVtLnZhbCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxlbS5kYXRhKCdvbGRWYWwnLCBlbGVtLnZhbCgpKTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZmllbGRcbiAgICAgICAgaWYgKGVsZW0udmFsKCkudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZWxlbS5hZGRDbGFzcygnaW5zdHlsZV9lcnJvciBoYXMtLWVycm9yJyk7XG4gICAgICAgICAgICBtZS5tYXJrRmllbGRJbnZhbGlkKCdjYXJkSG9sZGVyJywgJ2ludmFsaWRfY2FyZF9ob2xkZXInKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoJ2luc3R5bGVfZXJyb3IgaGFzLS1lcnJvcicpO1xuICAgICAgICAgICAgbWUubWFya0ZpZWxkVmFsaWQoJ2NhcmRIb2xkZXInKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjaGFuZ2Ugb2JzZXJ2ZXIgdG8gdGhlIGNhcmQgc2VsZWN0aW9uIGZpZWxkLiBJZiBhbiBleGlzdGluZyBjYXJkIGlzIHNlbGVjdGVkLCBhbGwgZm9ybSBmaWVsZHMgYXJlIGhpZGRlblxuICAgICAqIGFuZCB0aGUgY2FyZCdzIFN0cmlwZSBpbmZvcm1hdGlvbiBpcyBhZGRlZCB0byB0aGUgZm9ybS4gSWYgdGhlICduZXcnIG9wdGlvbiBpcyBzZWxlY3RlZCwgYWxsIGZpZWxkcyBtYWRlIHZpc2libGVcbiAgICAgKiBhbmQgdGhlIFN0cmlwZSBjYXJkIGluZm8gaXMgcmVtb3ZlZCBmcm9tIHRoZSBmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIE9iamVjdCBldmVudFxuICAgICAqL1xuICAgIG9uQ2FyZFNlbGVjdGlvbkNoYW5nZShldmVudCkge1xuICAgICAgICBjb25zdCBtZSA9IGV2ZW50LmRhdGEuc2NvcGU7XG4gICAgICAgIGNvbnN0IGVsZW0gPSAkKHRoaXMpO1xuXG4gICAgICAgIGlmIChlbGVtLnZhbCgpID09PSAnbmV3Jykge1xuICAgICAgICAgICAgLy8gQSBuZXcsIGVtcHR5IGNhcmQgd2FzIHNlbGVjdGVkXG4gICAgICAgICAgICBtZS5zZXRTZWxlY3RlZENhcmQobnVsbCk7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgdmFsaWRhdGlvbiBlcnJvcnMgdmlzaWJsZVxuICAgICAgICAgICAgbWUudXBkYXRlVmFsaWRhdGlvbkVycm9ycygpO1xuXG4gICAgICAgICAgICAvLyBTaG93IHRoZSBzYXZlIGNoZWNrIGJveFxuICAgICAgICAgICAgbWUuZm9ybUVsKCcuc3RyaXBlLWNhcmQtZmllbGQnKS5zaG93KCk7XG4gICAgICAgICAgICBtZS5mb3JtRWwoJy5zdHJpcGUtc2F2ZS1jYXJkJykuc2hvdygpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCB0aGUgc2VsZWN0ZWQgY2FyZFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lLm9wdGlvbnMuYXZhaWxhYmxlQ2FyZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkQ2FyZCA9IG1lLm9wdGlvbnMuYXZhaWxhYmxlQ2FyZHNbaV07XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRDYXJkLmlkICE9PSBlbGVtLnZhbCgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNhcmRcbiAgICAgICAgICAgIG1lLnNldFNlbGVjdGVkQ2FyZChzZWxlY3RlZENhcmQpO1xuXG4gICAgICAgICAgICAvLyBIaWRlIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgICAgICAgICBtZS5mb3JtRWwoJy5zdHJpcGUtcGF5bWVudC12YWxpZGF0aW9uLWVycm9yLWJveCcpLmhpZGUoKTtcblxuICAgICAgICAgICAgLy8gSGlkZSBhbGwgY2FyZCBmaWVsZHNcbiAgICAgICAgICAgIG1lLmZvcm1FbCgnLnN0cmlwZS1jYXJkLWZpZWxkJykuaGlkZSgpO1xuICAgICAgICAgICAgbWUuZm9ybUVsKCcuc3RyaXBlLXNhdmUtY2FyZCcpLmhpZGUoKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBib3RoIHN1Ym1pdCBidXR0b25zIG9uIHRoZSBwYWdlIGFuZCBhZGRzIHRoZSAnZGlzYWJsZWQnIGF0dHJpYnV0ZSBhcyB3ZWxsIGFzIHRoZSBsb2FkaW5nIGluZGljYXRvciB0byBlYWNoXG4gICAgICogb2YgdGhlbS5cbiAgICAgKi9cbiAgICBzZXRTdWJtaXRCdXR0b25zTG9hZGluZygpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIGJ1dHRvbiBmaXJzdCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgYWRkZWQgbXVsdGlwbGUgbG9hZGluZyBpbmRpY2F0b3JzXG4gICAgICAgIHRoaXMucmVzZXRTdWJtaXRCdXR0b25zKCk7XG4gICAgICAgICQoJyNjb25maXJtUGF5bWVudEZvcm0gYnV0dG9uW3R5cGU9XCJzdWJtaXRcIl0sIC5jb25maXJtLS1hY3Rpb25zIGJ1dHRvbltmb3JtPVwiY29uZmlybVBheW1lbnRGb3JtXCJdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQodGhpcykuaHRtbCgkKHRoaXMpLnRleHQoKSArICc8ZGl2IGNsYXNzPVwianMtLWxvYWRpbmdcIj48L2Rpdj4nKS5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBib3RoIHN1Ym1pdCBidXR0b25zIG9uIHRoZSBwYWdlIGFuZCByZXNldHMgdGhlbSBieSByZW1vdmluZyB0aGUgJ2Rpc2FibGVkJyBhdHRyaWJ1dGUgYXMgd2VsbCBhcyB0aGVcbiAgICAgKiBsb2FkaW5nIGluZGljYXRvci5cbiAgICAgKi9cbiAgICByZXNldFN1Ym1pdEJ1dHRvbnMoKSB7XG4gICAgICAgICQoJyNjb25maXJtUGF5bWVudEZvcm0gYnV0dG9uW3R5cGU9XCJzdWJtaXRcIl0sIC5jb25maXJtLS1hY3Rpb25zIGJ1dHRvbltmb3JtPVwiY29uZmlybVBheW1lbnRGb3JtXCJdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQodGhpcykucmVtb3ZlQXR0cignZGlzYWJsZWQnKS5maW5kKCcuanMtLWxvYWRpbmcnKS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gbWVzc2FnZSBpbiB0aGUgZ2VuZXJhbCBlcnJvciBib3ggYW5kIHNjcm9sbHMgdGhlIHBhZ2UgdG8gbWFrZSBpdCB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIFN0cmluZyBtZXNzYWdlIEEgU3RyaXBlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgaGFuZGxlU3RyaXBlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAvLyBEaXNwbGF5IHRoZSBlcnJvciBpbmZvcm1hdGlvbiBhYm92ZSB0aGUgY3JlZGl0IGNhcmQgZm9ybSBhbmQgc2Nyb2xsIHRvIGl0cyBwb3NpdGlvblxuICAgICAgICB0aGlzLmZvcm1FbCgnLnN0cmlwZS1wYXltZW50LWVycm9yLWJveCcpLnNob3coKS5jaGlsZHJlbignLmVycm9yLWNvbnRlbnQnKS5odG1sKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWVzIHRvIGZpbmQgYSBzdHJpcGUgY2FyZCBmb3JtIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBwYXltZW50IG1ldGhvZC4gVGhhdCBpcywgaWYgYSBzdHJpcGUgY2FyZCBwYXltZW50XG4gICAgICogbWV0aG9kIGlzIHNlbGVjdGVkLCBpdHMgZm9ybSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4galF1ZXJ5fG51bGxcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVTdHJpcGVDYXJkRm9ybSgpIHtcbiAgICAgICAgY29uc3QgZm9ybSA9ICQoJ2lucHV0W2lkXj1cInBheW1lbnRNZXRob2RcIl06Y2hlY2tlZCcpLmNsb3Nlc3QoJy5wYXltZW50LW1ldGhvZCcpLmZpbmQoJy5zdHJpcGUtcGF5bWVudC1jYXJkLWZvcm0nKTtcblxuICAgICAgICByZXR1cm4gKGZvcm0ubGVuZ3RoID4gMCkgPyBmb3JtLmZpcnN0KCkgOiBudWxsO1xuICAgIH1cblxuICAgIGdldFN0cmlwZUNhcmRGb3JtKCkge1xuICAgICAgICBjb25zdCBmb3JtID0gJCgnaW5wdXRbaWRePVwicGF5bWVudE1ldGhvZFwiXScpLmNsb3Nlc3QoJy5wYXltZW50LW1ldGhvZCcpLmZpbmQoJy5zdHJpcGUtcGF5bWVudC1jYXJkLWZvcm0nKTtcblxuICAgICAgICByZXR1cm4gKGZvcm0ubGVuZ3RoID4gMCkgPyBmb3JtLmZpcnN0KCkgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBqUXVlcnkgcXVlcnkgb24gdGhlIERPTSB0cmVlIHVuZGVyIHRoZSBhY3RpdmUgc3RyaXBlIGNhcmQgZm9ybSB1c2luZyB0aGUgZ2l2ZW4gc2VsZWN0b3IuIFRoaXMgbWV0aG9kXG4gICAgICogc2hvdWxkIGJlIHVzZWQgd2hlbiBzZWxlY3RpbmcgYW55IGZpZWxkcyB0aGF0IGFyZSBwYXJ0IG9mIGEgU3RyaXBlIGNhcmQgcGF5bWVudCBmb3JtLiBJZiBubyBTdHJpcGUgY2FyZCBmb3JtIGlzXG4gICAgICogYWN0aXZlLCBhbiBlbXB0eSBxdWVyeSByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gU3RyaW5nIHNlbGVjdG9yXG4gICAgICogQHJldHVybiBqUXVlcnlcbiAgICAgKi9cbiAgICBmb3JtRWwoc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgZm9ybSA9IHRoaXMuZ2V0QWN0aXZlU3RyaXBlQ2FyZEZvcm0oKTtcbiAgICAgICAgcmV0dXJuIChmb3JtKSA/IGZvcm0uZmluZChzZWxlY3RvcikgOiAkKCdzdHJpcGVfcGF5bWVudF9jYXJkX25vdF9mb3VuZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4galF1ZXJ5IFRoZSBtYWluIHBheW1lbnQgc2VsZWN0aW9uIGZvcm0gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmaW5kRm9ybSgpIHtcbiAgICAgICAgcmV0dXJuICQoJyNjb25maXJtUGF5bWVudEZvcm0nKTtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBREE7QUFEQTtBQUNBO0FBWUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7Ozs7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUEzYkE7QUFDQTtBQURBO0FBRUE7OztBQUdBO0FBRUE7QUFFQTtBQUVBO0FBVkE7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:////TfR\n");

/***/ }),

/***/ "I6n5":
/*!******************************************************************************************************************************************************!*\
  !*** /home/felix/PhpstormProjects/shopware-6/plugins/ShopwareStripePayment/src/Resources/storefront/sepa-selection/stripe-payment.sepa-selection.js ***!
  \******************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return StripePaymentSepaSelection; });\n/* harmony import */ var src_script_service_http_client_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/script/service/http-client.service */ \"k8s9\");\n/* harmony import */ var src_script_plugin_system_plugin_class__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/script/plugin-system/plugin.class */ \"FGIj\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable import/no-unresolved */\n\n\n\nvar StripePaymentSepaSelection =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(StripePaymentSepaSelection, _Plugin);\n\n  function StripePaymentSepaSelection() {\n    _classCallCheck(this, StripePaymentSepaSelection);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(StripePaymentSepaSelection).apply(this, arguments));\n  }\n\n  _createClass(StripePaymentSepaSelection, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      this._client = new src_script_service_http_client_service__WEBPACK_IMPORTED_MODULE_0__[\"default\"](window.accessKey, window.contextToken);\n      this.stripeElements = [];\n      this.invalidFields = [];\n      this.options = _extends(StripePaymentSepaSelection.options, this.options || {});\n      /* eslint-disable no-undef */\n\n      this.stripeClient = Stripe(this.options.stripePublicKey); // Save config\n\n      this.setSelectedSepaBankAccount(this.options.selectedSepaBankAccount); // Setup form on payment method changes\n\n      var paymentMethodElements = document.querySelectorAll('input.payment-method-input');\n      paymentMethodElements.forEach(function (element) {\n        element.addEventListener('change', function () {\n          _this.setupForm();\n        });\n      });\n      this.setupForm();\n    }\n    /**\n     * Saves the given card and removes all hidden Stripe fields from the form. If the card exists, its ID as well as\n     * its encoded data are added to the form as hidden fields.\n     *\n     * @param sepaBankAccount A Stripe card object.\n     */\n\n  }, {\n    key: \"setSelectedSepaBankAccount\",\n    value: function setSelectedSepaBankAccount(sepaBankAccount) {\n      this.selectedSepaBankAccount = sepaBankAccount;\n\n      if (this.selectedSepaBankAccount) {\n        console.log(\"set sepaBankAccount \".concat(JSON.stringify(sepaBankAccount)));\n        this.selectedSepaBankAccountChanged = true;\n      }\n    }\n    /**\n     * Sets up the payment form by first unounting all Stripe elements that might be already mounted to the DOM and\n     * clearing all validation errors. Then, if a stripe card payment method is selected, mounts new Stripe Elements\n     * fields to the form and adds some observers to other fields as well as the form.\n     */\n\n  }, {\n    key: \"setupForm\",\n    value: function setupForm() {\n      // Reset form\n      this.unmountStripeElements();\n      this.invalidFields = [];\n      this.updateValidationErrors();\n\n      if (this.getActiveStripeSepaForm()) {\n        this.getStripeSepaForm().show(); // Mount Stripe form fields again to the now active form and add other observers\n\n        this.mountStripeElements();\n        this.observeForm(); //TODO: remove listeners as well on change\n        // Make sure the card selection matches the internal state\n\n        if (this.selectedSepaBankAccount) {\n          this.formEl('.stripe-saved-sepa-bank-accounts').val(this.selectedSepaBankAccount.id);\n        }\n\n        this.formEl('.stripe-saved-sepa-bank-accounts').trigger('change');\n      } else {\n        this.removeFormListeners();\n        this.getStripeSepaForm().hide();\n      }\n    }\n    /**\n     * Creates the Stripe Elements fields for card number, expiry and CVC and mounts them to their resepctive nodes in\n     * the active Stripe card payment form.\n     */\n\n  }, {\n    key: \"mountStripeElements\",\n    value: function mountStripeElements() {\n      // Define options to apply to all fields when creating them\n      var accountOwnerFieldEl = this.formEl('.stripe-sepa-account-owner');\n      var defaultOptions = {\n        style: {\n          base: {\n            color: accountOwnerFieldEl.css('color'),\n            fontFamily: accountOwnerFieldEl.css('font-family'),\n            fontSize: accountOwnerFieldEl.css('font-size'),\n            fontWeight: accountOwnerFieldEl.css('font-weight'),\n            lineHeight: accountOwnerFieldEl.css('line-height')\n          }\n        }\n      }; // Define a closure to create all elements using the same 'Elements' instance\n\n      var elements = this.stripeClient.elements({\n        locale: this.options.locale\n      });\n      var me = this;\n\n      var createAndMountStripeElement = function createAndMountStripeElement(type, mountSelector) {\n        // Create the element and add the change listener\n        var options = defaultOptions;\n\n        if (type === 'iban') {\n          options = _extends(options, {\n            supportedCountries: ['SEPA'],\n            placeholderCountry: me.options.customerCountry\n          });\n        }\n\n        var element = elements.create(type, options);\n        element.on('change', function (event) {\n          if (event.error && event.error.type === 'validation_error') {\n            me.markFieldInvalid(type, event.error.code, event.error.message);\n          } else {\n            me.markFieldValid(type);\n          }\n        }); // Mount it to the DOM\n\n        var mountElement = me.formEl(mountSelector).get(0);\n        element.mount(mountElement);\n        return element;\n      }; // Create all elements\n\n\n      this.stripeElements = [createAndMountStripeElement('iban', '.stripe-element-sepa-iban')];\n    }\n    /**\n     * Unmounts all existing Stripe elements from the Stripe card payment form they are currently mounted to.\n     */\n\n  }, {\n    key: \"unmountStripeElements\",\n    value: function unmountStripeElements() {\n      this.stripeElements.forEach(function (element) {\n        return element.unmount();\n      });\n      this.stripeElements = [];\n    }\n    /**\n     * Checks the list of invalid fields for any entries and, if found, joins them to an error message, which is then\n     * displayed in the error box. If no invalid fields are found, the error box is hidden.\n     */\n\n  }, {\n    key: \"updateValidationErrors\",\n    value: function updateValidationErrors() {\n      var _this2 = this;\n\n      var errorBox = this.formEl('.stripe-payment-validation-error-box');\n      var boxContent = errorBox.find('.error-content');\n      boxContent.empty();\n\n      if (Object.keys(this.invalidFields).length > 0) {\n        // Update the error box message and make it visible\n        var listEl = $('<ul></ul>').addClass('alert--list').appendTo(boxContent);\n        Object.keys(this.invalidFields).forEach(function (key) {\n          $('<li></li>').addClass('list--entry').text(_this2.invalidFields[key]).appendTo(listEl);\n        });\n        errorBox.show();\n      } else {\n        errorBox.hide();\n      }\n    }\n    /**\n     * Adds change listeners to the card selection and card holder field as well as a submission listener on the main\n     * payment form.\n     */\n\n  }, {\n    key: \"observeForm\",\n    value: function observeForm() {\n      // Add listeners\n      this.findForm().on('submit', {\n        scope: this\n      }, this.onFormSubmission);\n      this.formEl('.stripe-saved-sepa-bank-accounts').on('change', {\n        scope: this\n      }, this.onSepaBankAccountSelectionChange);\n      var me = this;\n      this.formEl('input[class^=\"stripe-sepa-\"]').each(function () {\n        // Save the current value and add listener\n        var elem = $(this);\n        elem.data('oldVal', elem.val());\n        elem.on('propertychange keyup input paste', {\n          scope: me\n        }, me.onFieldChange);\n      });\n    }\n  }, {\n    key: \"removeFormListeners\",\n    value: function removeFormListeners() {\n      this.findForm().off('submit', this.onFormSubmission);\n      this.formEl('.stripe-saved-sepa-bank-accounts').off('change', this.onSepaBankAccountSelectionChange);\n      var me = this;\n      this.formEl('input[class^=\"stripe-sepa-\"]').each(function () {\n        // Save the current value and add listener\n        var elem = $(this);\n        elem.off('propertychange keyup input paste', me.onFieldChange);\n      });\n    }\n    /**\n     * Validates the field value to not be empty. If the validation failes, the field is marked invalid.\n     *\n     * @param Event event\n     * @param boolean|undefined force\n     */\n\n  }, {\n    key: \"onFieldChange\",\n    value: function onFieldChange(event, force) {\n      var me = event.data.scope;\n      var elem = $(this);\n      var name = elem.attr('name'); // Check if value has changed, if 'force' is not set\n\n      if (!force && elem.data('oldVal') === elem.val()) {\n        return;\n      }\n\n      elem.data('oldVal', elem.val()); // Validate the field\n\n      if (elem.val().trim().length === 0) {\n        elem.addClass('instyle_error has--error');\n        me.markFieldInvalid(name, 'invalid_' + name);\n      } else {\n        elem.removeClass('instyle_error has--error');\n        me.markFieldValid(name);\n      }\n    }\n    /**\n     * Removes all validation errors for the field with the given 'fieldId' and triggers an update of the displayed\n     * validation errors.\n     *\n     * @param String fieldId\n     */\n\n  }, {\n    key: \"markFieldValid\",\n    value: function markFieldValid(fieldId) {\n      delete this.invalidFields[fieldId];\n      this.updateValidationErrors();\n    }\n    /**\n     * Determines the error message based on the given 'errorCode' and 'message' and triggers\n     * an update of the displayed validation errors.\n     *\n     * @param fieldId\n     * @param errorCode (optional) The code used to find a localised error message.\n     * @param message (optioanl) The fallback error message used in case no 'errorCode' is provided or no respective, localised description exists.\n     */\n\n  }, {\n    key: \"markFieldInvalid\",\n    value: function markFieldInvalid(fieldId, errorCode, message) {\n      // TODO: add localized error with snippets if avail\n      this.invalidFields[fieldId] = message || 'Unknown error';\n      this.updateValidationErrors();\n    }\n    /**\n     * First validates the form and payment state and, if the main form can be submitted, does nothing further.\n     * If however the main form cannot be submitted, because no card is selected (or no token was created), a new Stripe\n     * card and token are generated using the entered card data and saved in the form, before the submission is\n     * triggered again.\n     *\n     * @param event\n     */\n\n  }, {\n    key: \"onFormSubmission\",\n    value: function onFormSubmission(event) {\n      var me = event.data.scope;\n      var form = $(this); // Not the currently selected payment method\n\n      if (!me.getActiveStripeSepaForm()) {\n        return undefined;\n      } // Check if a token/card was generated and hence the form can be submitted\n\n\n      if (me.selectedSepaBankAccount) {\n        if (!me.selectedSepaBankAccountChanged) {\n          return undefined;\n        }\n\n        me.unmountStripeElements();\n        event.preventDefault();\n\n        me._client.post(me.options.persistUrl, JSON.stringify({\n          selectedSepaBankAccount: me.selectedSepaBankAccount\n        }), function (res) {\n          var result = JSON.parse(res);\n\n          if (!result.success) {\n            return;\n          }\n\n          me.selectedSepaBankAccountChanged = null; // Submit the form again to finish the payment process\n\n          form.submit();\n        });\n\n        return;\n      } // Prevent the form from being submitted until a new Stripe token is generated and received\n\n\n      event.preventDefault(); // Check for invalid fields\n\n      if (Object.keys(me.invalidFields).length > 0) {\n        return;\n      } // Send the credit card information to Stripe\n\n\n      me.setSubmitButtonsLoading();\n      me.stripeClient.createPaymentMethod('sepa_debit', me.stripeElements[0], {\n        billing_details: {\n          name: me.formEl('input.stripe-sepa-account-owner').val(),\n          email: me.formEl('input.stripe-sepa-email').val(),\n          address: {\n            line1: me.formEl('input.stripe-sepa-street').val(),\n            city: me.formEl('input.stripe-sepa-zip-code').val(),\n            postal_code: me.formEl('input.stripe-sepa-city').val(),\n            country: me.formEl('select.stripe-sepa-country').val()\n          }\n        }\n      }).then(function (result) {\n        if (result.error) {\n          // Only reset the submit buttons in case of an error, because otherwise the form is submitted again\n          // right aways and hence we want the buttons to stay disabled\n          me.resetSubmitButtons(); // Display the error\n          // TODO: add localized error with snippets if avail\n\n          var message = result.error.message || 'Unknown error';\n          me.handleStripeError('Error: ' + message);\n        } else {\n          // Save the card information\n          var sepaBankAccount = result.paymentMethod.sepa_debit;\n          sepaBankAccount.id = result.paymentMethod.id;\n          sepaBankAccount.name = me.formEl('.stripe-sepa-account-owner').val();\n          me.setSelectedSepaBankAccount(sepaBankAccount);\n          var saveSepaBankAccount = me.formEl('.stripe-save-sepa-bank-account').is(':checked');\n\n          try {\n            me._client.post(me.options.persistUrl, JSON.stringify({\n              selectedSepaBankAccount: sepaBankAccount,\n              saveSepaBankAccount: saveSepaBankAccount\n            }), function (res) {\n              var result = JSON.parse(res);\n\n              if (!result.success) {\n                return;\n              } // Submit the form again to finish the payment process\n\n\n              form.submit();\n            });\n          } catch (err) {\n            /* eslint-disable no-debugger */\n            debugger;\n          }\n        }\n      });\n    }\n    /**\n     * Adds a change observer to the card selection field. If an existing card is selected, all form fields are hidden\n     * and the card's Stripe information is added to the form. If the 'new' option is selected, all fields made visible\n     * and the Stripe card info is removed from the form.\n     *\n     * @param Object event\n     */\n\n  }, {\n    key: \"onSepaBankAccountSelectionChange\",\n    value: function onSepaBankAccountSelectionChange(event) {\n      var me = event.data.scope;\n      var elem = $(this);\n\n      if (elem.val() === 'new') {\n        // A new, empty card was selected\n        me.setSelectedSepaBankAccount(null); // Make validation errors visible\n\n        me.updateValidationErrors(); // Show the save check box\n\n        me.formEl('.stripe-sepa-field').show();\n        me.formEl('.stripe-save-sepa-bank-account').show().prop('checked', true);\n        return;\n      } // Find the selected card\n\n\n      for (var i = 0; i < me.options.availableSepaBankAccounts.length; i++) {\n        var selectedSepaBankAccount = me.options.availableSepaBankAccounts[i];\n\n        if (selectedSepaBankAccount.id !== elem.val()) {\n          continue;\n        } // Save the card\n\n\n        if (!me.selectedSepaBankAccount || me.selectedSepaBankAccount.id !== selectedSepaBankAccount.id) {\n          me.setSelectedSepaBankAccount(selectedSepaBankAccount);\n        } // Hide validation errors\n\n\n        me.formEl('.stripe-payment-validation-error-box').hide(); // Hide all sepa fields\n\n        me.formEl('.stripe-sepa-field').hide();\n        me.formEl('.stripe-save-bank-account').hide();\n        break;\n      }\n    }\n    /**\n     * Finds both submit buttons on the page and adds the 'disabled' attribute as well as the loading indicator to each\n     * of them.\n     */\n\n  }, {\n    key: \"setSubmitButtonsLoading\",\n    value: function setSubmitButtonsLoading() {\n      // Reset the button first to prevent it from being added multiple loading indicators\n      this.resetSubmitButtons();\n      $('#confirmPaymentForm button[type=\"submit\"], .confirm--actions button[form=\"confirmPaymentForm\"]').each(function () {\n        $(this).html($(this).text() + '<div class=\"js--loading\"></div>').attr('disabled', 'disabled');\n      });\n    }\n    /**\n     * Finds both submit buttons on the page and resets them by removing the 'disabled' attribute as well as the\n     * loading indicator.\n     */\n\n  }, {\n    key: \"resetSubmitButtons\",\n    value: function resetSubmitButtons() {\n      $('#confirmPaymentForm button[type=\"submit\"], .confirm--actions button[form=\"confirmPaymentForm\"]').each(function () {\n        $(this).removeAttr('disabled').find('.js--loading').remove();\n      });\n    }\n    /**\n     * Sets the given message in the general error box and scrolls the page to make it visible.\n     *\n     * @param String message A Stripe error message.\n     */\n\n  }, {\n    key: \"handleStripeError\",\n    value: function handleStripeError(message) {\n      // Display the error information above the credit card form and scroll to its position\n      this.formEl('.stripe-payment-error-box').show().children('.error-content').html(message);\n    }\n    /**\n     * Tries to find a stripe card form for the currently active payment method. That is, if a stripe card payment\n     * method is selected, its form is returned, otherwise returns null.\n     *\n     * @return jQuery|null\n     */\n\n  }, {\n    key: \"getActiveStripeSepaForm\",\n    value: function getActiveStripeSepaForm() {\n      var form = $('input[id^=\"paymentMethod\"]:checked').closest('.payment-method').find('.stripe-payment-sepa-form');\n      return form.length > 0 ? form.first() : null;\n    }\n  }, {\n    key: \"getStripeSepaForm\",\n    value: function getStripeSepaForm() {\n      var form = $('input[id^=\"paymentMethod\"]').closest('.payment-method').find('.stripe-payment-sepa-form');\n      return form.length > 0 ? form.first() : null;\n    }\n    /**\n     * Applies a jQuery query on the DOM tree under the active stripe card form using the given selector. This method\n     * should be used when selecting any fields that are part of a Stripe card payment form. If no Stripe card form is\n     * active, an empty query result is returned.\n     *\n     * @param String selector\n     * @return jQuery\n     */\n\n  }, {\n    key: \"formEl\",\n    value: function formEl(selector) {\n      var form = this.getActiveStripeSepaForm();\n      return form ? form.find(selector) : $('stripe_payment_bank_account_not_found');\n    }\n    /**\n     * @return jQuery The main payment selection form element.\n     */\n\n  }, {\n    key: \"findForm\",\n    value: function findForm() {\n      return $('#confirmPaymentForm');\n    }\n  }]);\n\n  return StripePaymentSepaSelection;\n}(src_script_plugin_system_plugin_class__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n_defineProperty(StripePaymentSepaSelection, \"options\", {\n  /**\n   * @type string\n   */\n  stripePublicKey: '',\n  selectedSepaBankAccount: null,\n  availableSepaBankAccounts: [],\n  locale: 'en'\n});\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! /home/felix/PhpstormProjects/shopware-6/shopware-development/vendor/shopware/platform/src/Storefront/Resources/node_modules/jquery/dist/jquery.slim.js */ \"wpjq\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSTZuNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9mZWxpeC9QaHBzdG9ybVByb2plY3RzL3Nob3B3YXJlLTYvcGx1Z2lucy9TaG9wd2FyZVN0cmlwZVBheW1lbnQvc3JjL1Jlc291cmNlcy9zdG9yZWZyb250L3NlcGEtc2VsZWN0aW9uL3N0cmlwZS1wYXltZW50LnNlcGEtc2VsZWN0aW9uLmpzP2MwZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLXVucmVzb2x2ZWQgKi9cblxuaW1wb3J0IEh0dHBDbGllbnQgZnJvbSAnc3JjL3NjcmlwdC9zZXJ2aWNlL2h0dHAtY2xpZW50LnNlcnZpY2UnO1xuaW1wb3J0IFBsdWdpbiBmcm9tICdzcmMvc2NyaXB0L3BsdWdpbi1zeXN0ZW0vcGx1Z2luLmNsYXNzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaXBlUGF5bWVudFNlcGFTZWxlY3Rpb24gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHN0YXRpYyBvcHRpb25zID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzdHJpcGVQdWJsaWNLZXk6ICcnLFxuXG4gICAgICAgIHNlbGVjdGVkU2VwYUJhbmtBY2NvdW50OiBudWxsLFxuXG4gICAgICAgIGF2YWlsYWJsZVNlcGFCYW5rQWNjb3VudHM6IFtdLFxuXG4gICAgICAgIGxvY2FsZTogJ2VuJyxcbiAgICB9O1xuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gbmV3IEh0dHBDbGllbnQod2luZG93LmFjY2Vzc0tleSwgd2luZG93LmNvbnRleHRUb2tlbik7XG4gICAgICAgIHRoaXMuc3RyaXBlRWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnZhbGlkRmllbGRzID0gW107XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihTdHJpcGVQYXltZW50U2VwYVNlbGVjdGlvbi5vcHRpb25zLCB0aGlzLm9wdGlvbnMgfHwge30pO1xuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgICAgIHRoaXMuc3RyaXBlQ2xpZW50ID0gU3RyaXBlKHRoaXMub3B0aW9ucy5zdHJpcGVQdWJsaWNLZXkpO1xuICAgICAgICAvLyBTYXZlIGNvbmZpZ1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkU2VwYUJhbmtBY2NvdW50KHRoaXMub3B0aW9ucy5zZWxlY3RlZFNlcGFCYW5rQWNjb3VudCk7XG5cbiAgICAgICAgLy8gU2V0dXAgZm9ybSBvbiBwYXltZW50IG1ldGhvZCBjaGFuZ2VzXG4gICAgICAgIGNvbnN0IHBheW1lbnRNZXRob2RFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LnBheW1lbnQtbWV0aG9kLWlucHV0Jyk7XG4gICAgICAgIHBheW1lbnRNZXRob2RFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cEZvcm0oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNldHVwRm9ybSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSBnaXZlbiBjYXJkIGFuZCByZW1vdmVzIGFsbCBoaWRkZW4gU3RyaXBlIGZpZWxkcyBmcm9tIHRoZSBmb3JtLiBJZiB0aGUgY2FyZCBleGlzdHMsIGl0cyBJRCBhcyB3ZWxsIGFzXG4gICAgICogaXRzIGVuY29kZWQgZGF0YSBhcmUgYWRkZWQgdG8gdGhlIGZvcm0gYXMgaGlkZGVuIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXBhQmFua0FjY291bnQgQSBTdHJpcGUgY2FyZCBvYmplY3QuXG4gICAgICovXG4gICAgc2V0U2VsZWN0ZWRTZXBhQmFua0FjY291bnQoc2VwYUJhbmtBY2NvdW50KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRTZXBhQmFua0FjY291bnQgPSBzZXBhQmFua0FjY291bnQ7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkU2VwYUJhbmtBY2NvdW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgc2V0IHNlcGFCYW5rQWNjb3VudCAke0pTT04uc3RyaW5naWZ5KHNlcGFCYW5rQWNjb3VudCl9YCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2VwYUJhbmtBY2NvdW50Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBwYXltZW50IGZvcm0gYnkgZmlyc3QgdW5vdW50aW5nIGFsbCBTdHJpcGUgZWxlbWVudHMgdGhhdCBtaWdodCBiZSBhbHJlYWR5IG1vdW50ZWQgdG8gdGhlIERPTSBhbmRcbiAgICAgKiBjbGVhcmluZyBhbGwgdmFsaWRhdGlvbiBlcnJvcnMuIFRoZW4sIGlmIGEgc3RyaXBlIGNhcmQgcGF5bWVudCBtZXRob2QgaXMgc2VsZWN0ZWQsIG1vdW50cyBuZXcgU3RyaXBlIEVsZW1lbnRzXG4gICAgICogZmllbGRzIHRvIHRoZSBmb3JtIGFuZCBhZGRzIHNvbWUgb2JzZXJ2ZXJzIHRvIG90aGVyIGZpZWxkcyBhcyB3ZWxsIGFzIHRoZSBmb3JtLlxuICAgICAqL1xuICAgIHNldHVwRm9ybSgpIHtcbiAgICAgICAgLy8gUmVzZXQgZm9ybVxuICAgICAgICB0aGlzLnVubW91bnRTdHJpcGVFbGVtZW50cygpO1xuICAgICAgICB0aGlzLmludmFsaWRGaWVsZHMgPSBbXTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWxpZGF0aW9uRXJyb3JzKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0QWN0aXZlU3RyaXBlU2VwYUZvcm0oKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRTdHJpcGVTZXBhRm9ybSgpLnNob3coKTtcbiAgICAgICAgICAgIC8vIE1vdW50IFN0cmlwZSBmb3JtIGZpZWxkcyBhZ2FpbiB0byB0aGUgbm93IGFjdGl2ZSBmb3JtIGFuZCBhZGQgb3RoZXIgb2JzZXJ2ZXJzXG4gICAgICAgICAgICB0aGlzLm1vdW50U3RyaXBlRWxlbWVudHMoKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUZvcm0oKTsgLy9UT0RPOiByZW1vdmUgbGlzdGVuZXJzIGFzIHdlbGwgb24gY2hhbmdlXG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2FyZCBzZWxlY3Rpb24gbWF0Y2hlcyB0aGUgaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkU2VwYUJhbmtBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtRWwoJy5zdHJpcGUtc2F2ZWQtc2VwYS1iYW5rLWFjY291bnRzJykudmFsKHRoaXMuc2VsZWN0ZWRTZXBhQmFua0FjY291bnQuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb3JtRWwoJy5zdHJpcGUtc2F2ZWQtc2VwYS1iYW5rLWFjY291bnRzJykudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZvcm1MaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3RyaXBlU2VwYUZvcm0oKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBTdHJpcGUgRWxlbWVudHMgZmllbGRzIGZvciBjYXJkIG51bWJlciwgZXhwaXJ5IGFuZCBDVkMgYW5kIG1vdW50cyB0aGVtIHRvIHRoZWlyIHJlc2VwY3RpdmUgbm9kZXMgaW5cbiAgICAgKiB0aGUgYWN0aXZlIFN0cmlwZSBjYXJkIHBheW1lbnQgZm9ybS5cbiAgICAgKi9cbiAgICBtb3VudFN0cmlwZUVsZW1lbnRzKCkge1xuICAgICAgICAvLyBEZWZpbmUgb3B0aW9ucyB0byBhcHBseSB0byBhbGwgZmllbGRzIHdoZW4gY3JlYXRpbmcgdGhlbVxuICAgICAgICBjb25zdCBhY2NvdW50T3duZXJGaWVsZEVsID0gdGhpcy5mb3JtRWwoJy5zdHJpcGUtc2VwYS1hY2NvdW50LW93bmVyJyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBiYXNlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBhY2NvdW50T3duZXJGaWVsZEVsLmNzcygnY29sb3InKSxcbiAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogYWNjb3VudE93bmVyRmllbGRFbC5jc3MoJ2ZvbnQtZmFtaWx5JyksXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBhY2NvdW50T3duZXJGaWVsZEVsLmNzcygnZm9udC1zaXplJyksXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGFjY291bnRPd25lckZpZWxkRWwuY3NzKCdmb250LXdlaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBhY2NvdW50T3duZXJGaWVsZEVsLmNzcygnbGluZS1oZWlnaHQnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZWZpbmUgYSBjbG9zdXJlIHRvIGNyZWF0ZSBhbGwgZWxlbWVudHMgdXNpbmcgdGhlIHNhbWUgJ0VsZW1lbnRzJyBpbnN0YW5jZVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuc3RyaXBlQ2xpZW50LmVsZW1lbnRzKHtcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5vcHRpb25zLmxvY2FsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgY29uc3QgY3JlYXRlQW5kTW91bnRTdHJpcGVFbGVtZW50ID0gZnVuY3Rpb24odHlwZSwgbW91bnRTZWxlY3Rvcikge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBlbGVtZW50IGFuZCBhZGQgdGhlIGNoYW5nZSBsaXN0ZW5lclxuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnaWJhbicpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZENvdW50cmllczogWydTRVBBJ10sXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyQ291bnRyeTogbWUub3B0aW9ucy5jdXN0b21lckNvdW50cnksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHMuY3JlYXRlKHR5cGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZWxlbWVudC5vbignY2hhbmdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZXJyb3IgJiYgZXZlbnQuZXJyb3IudHlwZSA9PT0gJ3ZhbGlkYXRpb25fZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1hcmtGaWVsZEludmFsaWQodHlwZSwgZXZlbnQuZXJyb3IuY29kZSwgZXZlbnQuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUubWFya0ZpZWxkVmFsaWQodHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE1vdW50IGl0IHRvIHRoZSBET01cbiAgICAgICAgICAgIGNvbnN0IG1vdW50RWxlbWVudCA9IG1lLmZvcm1FbChtb3VudFNlbGVjdG9yKS5nZXQoMCk7XG4gICAgICAgICAgICBlbGVtZW50Lm1vdW50KG1vdW50RWxlbWVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbGwgZWxlbWVudHNcbiAgICAgICAgdGhpcy5zdHJpcGVFbGVtZW50cyA9IFtcbiAgICAgICAgICAgIGNyZWF0ZUFuZE1vdW50U3RyaXBlRWxlbWVudCgnaWJhbicsICcuc3RyaXBlLWVsZW1lbnQtc2VwYS1pYmFuJyksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYWxsIGV4aXN0aW5nIFN0cmlwZSBlbGVtZW50cyBmcm9tIHRoZSBTdHJpcGUgY2FyZCBwYXltZW50IGZvcm0gdGhleSBhcmUgY3VycmVudGx5IG1vdW50ZWQgdG8uXG4gICAgICovXG4gICAgdW5tb3VudFN0cmlwZUVsZW1lbnRzKCkge1xuICAgICAgICB0aGlzLnN0cmlwZUVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IGVsZW1lbnQudW5tb3VudCgpKTtcbiAgICAgICAgdGhpcy5zdHJpcGVFbGVtZW50cyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgbGlzdCBvZiBpbnZhbGlkIGZpZWxkcyBmb3IgYW55IGVudHJpZXMgYW5kLCBpZiBmb3VuZCwgam9pbnMgdGhlbSB0byBhbiBlcnJvciBtZXNzYWdlLCB3aGljaCBpcyB0aGVuXG4gICAgICogZGlzcGxheWVkIGluIHRoZSBlcnJvciBib3guIElmIG5vIGludmFsaWQgZmllbGRzIGFyZSBmb3VuZCwgdGhlIGVycm9yIGJveCBpcyBoaWRkZW4uXG4gICAgICovXG4gICAgdXBkYXRlVmFsaWRhdGlvbkVycm9ycygpIHtcbiAgICAgICAgY29uc3QgZXJyb3JCb3ggPSB0aGlzLmZvcm1FbCgnLnN0cmlwZS1wYXltZW50LXZhbGlkYXRpb24tZXJyb3ItYm94Jyk7XG4gICAgICAgIGNvbnN0IGJveENvbnRlbnQgPSBlcnJvckJveC5maW5kKCcuZXJyb3ItY29udGVudCcpO1xuICAgICAgICBib3hDb250ZW50LmVtcHR5KCk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmludmFsaWRGaWVsZHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXJyb3IgYm94IG1lc3NhZ2UgYW5kIG1ha2UgaXQgdmlzaWJsZVxuICAgICAgICAgICAgY29uc3QgbGlzdEVsID0gJCgnPHVsPjwvdWw+JylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2FsZXJ0LS1saXN0JylcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oYm94Q29udGVudCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmludmFsaWRGaWVsZHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICQoJzxsaT48L2xpPicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnbGlzdC0tZW50cnknKVxuICAgICAgICAgICAgICAgICAgICAudGV4dCh0aGlzLmludmFsaWRGaWVsZHNba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGxpc3RFbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVycm9yQm94LnNob3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yQm94LmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgY2hhbmdlIGxpc3RlbmVycyB0byB0aGUgY2FyZCBzZWxlY3Rpb24gYW5kIGNhcmQgaG9sZGVyIGZpZWxkIGFzIHdlbGwgYXMgYSBzdWJtaXNzaW9uIGxpc3RlbmVyIG9uIHRoZSBtYWluXG4gICAgICogcGF5bWVudCBmb3JtLlxuICAgICAqL1xuICAgIG9ic2VydmVGb3JtKCkge1xuICAgICAgICAvLyBBZGQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuZmluZEZvcm0oKS5vbignc3VibWl0JywgeyBzY29wZTogdGhpcyB9LCB0aGlzLm9uRm9ybVN1Ym1pc3Npb24pO1xuICAgICAgICB0aGlzLmZvcm1FbCgnLnN0cmlwZS1zYXZlZC1zZXBhLWJhbmstYWNjb3VudHMnKS5vbignY2hhbmdlJywgeyBzY29wZTogdGhpcyB9LCB0aGlzLm9uU2VwYUJhbmtBY2NvdW50U2VsZWN0aW9uQ2hhbmdlKTtcblxuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZm9ybUVsKCdpbnB1dFtjbGFzc149XCJzdHJpcGUtc2VwYS1cIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgdmFsdWUgYW5kIGFkZCBsaXN0ZW5lclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9ICQodGhpcyk7XG4gICAgICAgICAgICBlbGVtLmRhdGEoJ29sZFZhbCcsIGVsZW0udmFsKCkpO1xuICAgICAgICAgICAgZWxlbS5vbigncHJvcGVydHljaGFuZ2Uga2V5dXAgaW5wdXQgcGFzdGUnLCB7IHNjb3BlOiBtZSB9LCBtZS5vbkZpZWxkQ2hhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlRm9ybUxpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5maW5kRm9ybSgpLm9mZignc3VibWl0JywgdGhpcy5vbkZvcm1TdWJtaXNzaW9uKTtcbiAgICAgICAgdGhpcy5mb3JtRWwoJy5zdHJpcGUtc2F2ZWQtc2VwYS1iYW5rLWFjY291bnRzJykub2ZmKCdjaGFuZ2UnLCB0aGlzLm9uU2VwYUJhbmtBY2NvdW50U2VsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICB0aGlzLmZvcm1FbCgnaW5wdXRbY2xhc3NePVwic3RyaXBlLXNlcGEtXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHZhbHVlIGFuZCBhZGQgbGlzdGVuZXJcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSAkKHRoaXMpO1xuICAgICAgICAgICAgZWxlbS5vZmYoJ3Byb3BlcnR5Y2hhbmdlIGtleXVwIGlucHV0IHBhc3RlJywgbWUub25GaWVsZENoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgZmllbGQgdmFsdWUgdG8gbm90IGJlIGVtcHR5LiBJZiB0aGUgdmFsaWRhdGlvbiBmYWlsZXMsIHRoZSBmaWVsZCBpcyBtYXJrZWQgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBFdmVudCBldmVudFxuICAgICAqIEBwYXJhbSBib29sZWFufHVuZGVmaW5lZCBmb3JjZVxuICAgICAqL1xuICAgIG9uRmllbGRDaGFuZ2UoZXZlbnQsIGZvcmNlKSB7XG4gICAgICAgIGNvbnN0IG1lID0gZXZlbnQuZGF0YS5zY29wZTtcbiAgICAgICAgY29uc3QgZWxlbSA9ICQodGhpcyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBlbGVtLmF0dHIoJ25hbWUnKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB2YWx1ZSBoYXMgY2hhbmdlZCwgaWYgJ2ZvcmNlJyBpcyBub3Qgc2V0XG4gICAgICAgIGlmICghZm9yY2UgJiYgZWxlbS5kYXRhKCdvbGRWYWwnKSA9PT0gZWxlbS52YWwoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsZW0uZGF0YSgnb2xkVmFsJywgZWxlbS52YWwoKSk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGZpZWxkXG4gICAgICAgIGlmIChlbGVtLnZhbCgpLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVsZW0uYWRkQ2xhc3MoJ2luc3R5bGVfZXJyb3IgaGFzLS1lcnJvcicpO1xuICAgICAgICAgICAgbWUubWFya0ZpZWxkSW52YWxpZChuYW1lLCAoJ2ludmFsaWRfJyArIG5hbWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoJ2luc3R5bGVfZXJyb3IgaGFzLS1lcnJvcicpO1xuICAgICAgICAgICAgbWUubWFya0ZpZWxkVmFsaWQobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB2YWxpZGF0aW9uIGVycm9ycyBmb3IgdGhlIGZpZWxkIHdpdGggdGhlIGdpdmVuICdmaWVsZElkJyBhbmQgdHJpZ2dlcnMgYW4gdXBkYXRlIG9mIHRoZSBkaXNwbGF5ZWRcbiAgICAgKiB2YWxpZGF0aW9uIGVycm9ycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBTdHJpbmcgZmllbGRJZFxuICAgICAqL1xuICAgIG1hcmtGaWVsZFZhbGlkKGZpZWxkSWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaW52YWxpZEZpZWxkc1tmaWVsZElkXTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWxpZGF0aW9uRXJyb3JzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gJ2Vycm9yQ29kZScgYW5kICdtZXNzYWdlJyBhbmQgdHJpZ2dlcnNcbiAgICAgKiBhbiB1cGRhdGUgb2YgdGhlIGRpc3BsYXllZCB2YWxpZGF0aW9uIGVycm9ycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZElkXG4gICAgICogQHBhcmFtIGVycm9yQ29kZSAob3B0aW9uYWwpIFRoZSBjb2RlIHVzZWQgdG8gZmluZCBhIGxvY2FsaXNlZCBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIChvcHRpb2FubCkgVGhlIGZhbGxiYWNrIGVycm9yIG1lc3NhZ2UgdXNlZCBpbiBjYXNlIG5vICdlcnJvckNvZGUnIGlzIHByb3ZpZGVkIG9yIG5vIHJlc3BlY3RpdmUsIGxvY2FsaXNlZCBkZXNjcmlwdGlvbiBleGlzdHMuXG4gICAgICovXG4gICAgbWFya0ZpZWxkSW52YWxpZChmaWVsZElkLCBlcnJvckNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVE9ETzogYWRkIGxvY2FsaXplZCBlcnJvciB3aXRoIHNuaXBwZXRzIGlmIGF2YWlsXG4gICAgICAgIHRoaXMuaW52YWxpZEZpZWxkc1tmaWVsZElkXSA9IG1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbGlkYXRpb25FcnJvcnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCB2YWxpZGF0ZXMgdGhlIGZvcm0gYW5kIHBheW1lbnQgc3RhdGUgYW5kLCBpZiB0aGUgbWFpbiBmb3JtIGNhbiBiZSBzdWJtaXR0ZWQsIGRvZXMgbm90aGluZyBmdXJ0aGVyLlxuICAgICAqIElmIGhvd2V2ZXIgdGhlIG1haW4gZm9ybSBjYW5ub3QgYmUgc3VibWl0dGVkLCBiZWNhdXNlIG5vIGNhcmQgaXMgc2VsZWN0ZWQgKG9yIG5vIHRva2VuIHdhcyBjcmVhdGVkKSwgYSBuZXcgU3RyaXBlXG4gICAgICogY2FyZCBhbmQgdG9rZW4gYXJlIGdlbmVyYXRlZCB1c2luZyB0aGUgZW50ZXJlZCBjYXJkIGRhdGEgYW5kIHNhdmVkIGluIHRoZSBmb3JtLCBiZWZvcmUgdGhlIHN1Ym1pc3Npb24gaXNcbiAgICAgKiB0cmlnZ2VyZWQgYWdhaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkZvcm1TdWJtaXNzaW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1lID0gZXZlbnQuZGF0YS5zY29wZTtcbiAgICAgICAgY29uc3QgZm9ybSA9ICQodGhpcyk7XG5cbiAgICAgICAgLy8gTm90IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcGF5bWVudCBtZXRob2RcbiAgICAgICAgaWYgKCFtZS5nZXRBY3RpdmVTdHJpcGVTZXBhRm9ybSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYSB0b2tlbi9jYXJkIHdhcyBnZW5lcmF0ZWQgYW5kIGhlbmNlIHRoZSBmb3JtIGNhbiBiZSBzdWJtaXR0ZWRcbiAgICAgICAgaWYgKG1lLnNlbGVjdGVkU2VwYUJhbmtBY2NvdW50KSB7XG4gICAgICAgICAgICBpZiAoIW1lLnNlbGVjdGVkU2VwYUJhbmtBY2NvdW50Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnVubW91bnRTdHJpcGVFbGVtZW50cygpO1xuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbWUuX2NsaWVudC5wb3N0KG1lLm9wdGlvbnMucGVyc2lzdFVybCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkU2VwYUJhbmtBY2NvdW50OiBtZS5zZWxlY3RlZFNlcGFCYW5rQWNjb3VudCxcbiAgICAgICAgICAgIH0pLCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZS5zZWxlY3RlZFNlcGFCYW5rQWNjb3VudENoYW5nZWQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VibWl0IHRoZSBmb3JtIGFnYWluIHRvIGZpbmlzaCB0aGUgcGF5bWVudCBwcm9jZXNzXG4gICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBmb3JtIGZyb20gYmVpbmcgc3VibWl0dGVkIHVudGlsIGEgbmV3IFN0cmlwZSB0b2tlbiBpcyBnZW5lcmF0ZWQgYW5kIHJlY2VpdmVkXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludmFsaWQgZmllbGRzXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhtZS5pbnZhbGlkRmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZW5kIHRoZSBjcmVkaXQgY2FyZCBpbmZvcm1hdGlvbiB0byBTdHJpcGVcbiAgICAgICAgbWUuc2V0U3VibWl0QnV0dG9uc0xvYWRpbmcoKTtcbiAgICAgICAgbWUuc3RyaXBlQ2xpZW50LmNyZWF0ZVBheW1lbnRNZXRob2QoJ3NlcGFfZGViaXQnLCBtZS5zdHJpcGVFbGVtZW50c1swXSwge1xuICAgICAgICAgICAgYmlsbGluZ19kZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbWUuZm9ybUVsKCdpbnB1dC5zdHJpcGUtc2VwYS1hY2NvdW50LW93bmVyJykudmFsKCksXG4gICAgICAgICAgICAgICAgZW1haWw6IG1lLmZvcm1FbCgnaW5wdXQuc3RyaXBlLXNlcGEtZW1haWwnKS52YWwoKSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUxOiBtZS5mb3JtRWwoJ2lucHV0LnN0cmlwZS1zZXBhLXN0cmVldCcpLnZhbCgpLFxuICAgICAgICAgICAgICAgICAgICBjaXR5OiBtZS5mb3JtRWwoJ2lucHV0LnN0cmlwZS1zZXBhLXppcC1jb2RlJykudmFsKCksXG4gICAgICAgICAgICAgICAgICAgIHBvc3RhbF9jb2RlOiBtZS5mb3JtRWwoJ2lucHV0LnN0cmlwZS1zZXBhLWNpdHknKS52YWwoKSxcbiAgICAgICAgICAgICAgICAgICAgY291bnRyeTogbWUuZm9ybUVsKCdzZWxlY3Quc3RyaXBlLXNlcGEtY291bnRyeScpLnZhbCgpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc2V0IHRoZSBzdWJtaXQgYnV0dG9ucyBpbiBjYXNlIG9mIGFuIGVycm9yLCBiZWNhdXNlIG90aGVyd2lzZSB0aGUgZm9ybSBpcyBzdWJtaXR0ZWQgYWdhaW5cbiAgICAgICAgICAgICAgICAvLyByaWdodCBhd2F5cyBhbmQgaGVuY2Ugd2Ugd2FudCB0aGUgYnV0dG9ucyB0byBzdGF5IGRpc2FibGVkXG4gICAgICAgICAgICAgICAgbWUucmVzZXRTdWJtaXRCdXR0b25zKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBlcnJvclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFkZCBsb2NhbGl6ZWQgZXJyb3Igd2l0aCBzbmlwcGV0cyBpZiBhdmFpbFxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXN1bHQuZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcic7XG4gICAgICAgICAgICAgICAgbWUuaGFuZGxlU3RyaXBlRXJyb3IoJ0Vycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNhcmQgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBzZXBhQmFua0FjY291bnQgPSByZXN1bHQucGF5bWVudE1ldGhvZC5zZXBhX2RlYml0O1xuICAgICAgICAgICAgICAgIHNlcGFCYW5rQWNjb3VudC5pZCA9IHJlc3VsdC5wYXltZW50TWV0aG9kLmlkO1xuICAgICAgICAgICAgICAgIHNlcGFCYW5rQWNjb3VudC5uYW1lID0gbWUuZm9ybUVsKCcuc3RyaXBlLXNlcGEtYWNjb3VudC1vd25lcicpLnZhbCgpO1xuICAgICAgICAgICAgICAgIG1lLnNldFNlbGVjdGVkU2VwYUJhbmtBY2NvdW50KHNlcGFCYW5rQWNjb3VudCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzYXZlU2VwYUJhbmtBY2NvdW50ID0gbWUuZm9ybUVsKCcuc3RyaXBlLXNhdmUtc2VwYS1iYW5rLWFjY291bnQnKS5pcygnOmNoZWNrZWQnKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZS5fY2xpZW50LnBvc3QobWUub3B0aW9ucy5wZXJzaXN0VXJsLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFNlcGFCYW5rQWNjb3VudDogc2VwYUJhbmtBY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVNlcGFCYW5rQWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgfSksIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Ym1pdCB0aGUgZm9ybSBhZ2FpbiB0byBmaW5pc2ggdGhlIHBheW1lbnQgcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNoYW5nZSBvYnNlcnZlciB0byB0aGUgY2FyZCBzZWxlY3Rpb24gZmllbGQuIElmIGFuIGV4aXN0aW5nIGNhcmQgaXMgc2VsZWN0ZWQsIGFsbCBmb3JtIGZpZWxkcyBhcmUgaGlkZGVuXG4gICAgICogYW5kIHRoZSBjYXJkJ3MgU3RyaXBlIGluZm9ybWF0aW9uIGlzIGFkZGVkIHRvIHRoZSBmb3JtLiBJZiB0aGUgJ25ldycgb3B0aW9uIGlzIHNlbGVjdGVkLCBhbGwgZmllbGRzIG1hZGUgdmlzaWJsZVxuICAgICAqIGFuZCB0aGUgU3RyaXBlIGNhcmQgaW5mbyBpcyByZW1vdmVkIGZyb20gdGhlIGZvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gT2JqZWN0IGV2ZW50XG4gICAgICovXG4gICAgb25TZXBhQmFua0FjY291bnRTZWxlY3Rpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbWUgPSBldmVudC5kYXRhLnNjb3BlO1xuICAgICAgICBjb25zdCBlbGVtID0gJCh0aGlzKTtcblxuICAgICAgICBpZiAoZWxlbS52YWwoKSA9PT0gJ25ldycpIHtcbiAgICAgICAgICAgIC8vIEEgbmV3LCBlbXB0eSBjYXJkIHdhcyBzZWxlY3RlZFxuICAgICAgICAgICAgbWUuc2V0U2VsZWN0ZWRTZXBhQmFua0FjY291bnQobnVsbCk7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgdmFsaWRhdGlvbiBlcnJvcnMgdmlzaWJsZVxuICAgICAgICAgICAgbWUudXBkYXRlVmFsaWRhdGlvbkVycm9ycygpO1xuXG4gICAgICAgICAgICAvLyBTaG93IHRoZSBzYXZlIGNoZWNrIGJveFxuICAgICAgICAgICAgbWUuZm9ybUVsKCcuc3RyaXBlLXNlcGEtZmllbGQnKS5zaG93KCk7XG4gICAgICAgICAgICBtZS5mb3JtRWwoJy5zdHJpcGUtc2F2ZS1zZXBhLWJhbmstYWNjb3VudCcpLnNob3coKS5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIHNlbGVjdGVkIGNhcmRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZS5vcHRpb25zLmF2YWlsYWJsZVNlcGFCYW5rQWNjb3VudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkU2VwYUJhbmtBY2NvdW50ID0gbWUub3B0aW9ucy5hdmFpbGFibGVTZXBhQmFua0FjY291bnRzW2ldO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkU2VwYUJhbmtBY2NvdW50LmlkICE9PSBlbGVtLnZhbCgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNhcmRcbiAgICAgICAgICAgIGlmICghbWUuc2VsZWN0ZWRTZXBhQmFua0FjY291bnQgfHwgbWUuc2VsZWN0ZWRTZXBhQmFua0FjY291bnQuaWQgIT09IHNlbGVjdGVkU2VwYUJhbmtBY2NvdW50LmlkKSB7XG4gICAgICAgICAgICAgICAgbWUuc2V0U2VsZWN0ZWRTZXBhQmFua0FjY291bnQoc2VsZWN0ZWRTZXBhQmFua0FjY291bnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIaWRlIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgICAgICAgICBtZS5mb3JtRWwoJy5zdHJpcGUtcGF5bWVudC12YWxpZGF0aW9uLWVycm9yLWJveCcpLmhpZGUoKTtcblxuICAgICAgICAgICAgLy8gSGlkZSBhbGwgc2VwYSBmaWVsZHNcbiAgICAgICAgICAgIG1lLmZvcm1FbCgnLnN0cmlwZS1zZXBhLWZpZWxkJykuaGlkZSgpO1xuICAgICAgICAgICAgbWUuZm9ybUVsKCcuc3RyaXBlLXNhdmUtYmFuay1hY2NvdW50JykuaGlkZSgpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGJvdGggc3VibWl0IGJ1dHRvbnMgb24gdGhlIHBhZ2UgYW5kIGFkZHMgdGhlICdkaXNhYmxlZCcgYXR0cmlidXRlIGFzIHdlbGwgYXMgdGhlIGxvYWRpbmcgaW5kaWNhdG9yIHRvIGVhY2hcbiAgICAgKiBvZiB0aGVtLlxuICAgICAqL1xuICAgIHNldFN1Ym1pdEJ1dHRvbnNMb2FkaW5nKCkge1xuICAgICAgICAvLyBSZXNldCB0aGUgYnV0dG9uIGZpcnN0IHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZGRlZCBtdWx0aXBsZSBsb2FkaW5nIGluZGljYXRvcnNcbiAgICAgICAgdGhpcy5yZXNldFN1Ym1pdEJ1dHRvbnMoKTtcbiAgICAgICAgJCgnI2NvbmZpcm1QYXltZW50Rm9ybSBidXR0b25bdHlwZT1cInN1Ym1pdFwiXSwgLmNvbmZpcm0tLWFjdGlvbnMgYnV0dG9uW2Zvcm09XCJjb25maXJtUGF5bWVudEZvcm1cIl0nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5odG1sKCQodGhpcykudGV4dCgpICsgJzxkaXYgY2xhc3M9XCJqcy0tbG9hZGluZ1wiPjwvZGl2PicpLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGJvdGggc3VibWl0IGJ1dHRvbnMgb24gdGhlIHBhZ2UgYW5kIHJlc2V0cyB0aGVtIGJ5IHJlbW92aW5nIHRoZSAnZGlzYWJsZWQnIGF0dHJpYnV0ZSBhcyB3ZWxsIGFzIHRoZVxuICAgICAqIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgICAqL1xuICAgIHJlc2V0U3VibWl0QnV0dG9ucygpIHtcbiAgICAgICAgJCgnI2NvbmZpcm1QYXltZW50Rm9ybSBidXR0b25bdHlwZT1cInN1Ym1pdFwiXSwgLmNvbmZpcm0tLWFjdGlvbnMgYnV0dG9uW2Zvcm09XCJjb25maXJtUGF5bWVudEZvcm1cIl0nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpLmZpbmQoJy5qcy0tbG9hZGluZycpLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiBtZXNzYWdlIGluIHRoZSBnZW5lcmFsIGVycm9yIGJveCBhbmQgc2Nyb2xscyB0aGUgcGFnZSB0byBtYWtlIGl0IHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gU3RyaW5nIG1lc3NhZ2UgQSBTdHJpcGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBoYW5kbGVTdHJpcGVFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIC8vIERpc3BsYXkgdGhlIGVycm9yIGluZm9ybWF0aW9uIGFib3ZlIHRoZSBjcmVkaXQgY2FyZCBmb3JtIGFuZCBzY3JvbGwgdG8gaXRzIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuZm9ybUVsKCcuc3RyaXBlLXBheW1lbnQtZXJyb3ItYm94Jykuc2hvdygpLmNoaWxkcmVuKCcuZXJyb3ItY29udGVudCcpLmh0bWwobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZXMgdG8gZmluZCBhIHN0cmlwZSBjYXJkIGZvcm0gZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIHBheW1lbnQgbWV0aG9kLiBUaGF0IGlzLCBpZiBhIHN0cmlwZSBjYXJkIHBheW1lbnRcbiAgICAgKiBtZXRob2QgaXMgc2VsZWN0ZWQsIGl0cyBmb3JtIGlzIHJldHVybmVkLCBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICAgICAqXG4gICAgICogQHJldHVybiBqUXVlcnl8bnVsbFxuICAgICAqL1xuICAgIGdldEFjdGl2ZVN0cmlwZVNlcGFGb3JtKCkge1xuICAgICAgICBjb25zdCBmb3JtID0gJCgnaW5wdXRbaWRePVwicGF5bWVudE1ldGhvZFwiXTpjaGVja2VkJykuY2xvc2VzdCgnLnBheW1lbnQtbWV0aG9kJykuZmluZCgnLnN0cmlwZS1wYXltZW50LXNlcGEtZm9ybScpO1xuXG4gICAgICAgIHJldHVybiAoZm9ybS5sZW5ndGggPiAwKSA/IGZvcm0uZmlyc3QoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0U3RyaXBlU2VwYUZvcm0oKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSAkKCdpbnB1dFtpZF49XCJwYXltZW50TWV0aG9kXCJdJykuY2xvc2VzdCgnLnBheW1lbnQtbWV0aG9kJykuZmluZCgnLnN0cmlwZS1wYXltZW50LXNlcGEtZm9ybScpO1xuXG4gICAgICAgIHJldHVybiAoZm9ybS5sZW5ndGggPiAwKSA/IGZvcm0uZmlyc3QoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIGpRdWVyeSBxdWVyeSBvbiB0aGUgRE9NIHRyZWUgdW5kZXIgdGhlIGFjdGl2ZSBzdHJpcGUgY2FyZCBmb3JtIHVzaW5nIHRoZSBnaXZlbiBzZWxlY3Rvci4gVGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgYmUgdXNlZCB3aGVuIHNlbGVjdGluZyBhbnkgZmllbGRzIHRoYXQgYXJlIHBhcnQgb2YgYSBTdHJpcGUgY2FyZCBwYXltZW50IGZvcm0uIElmIG5vIFN0cmlwZSBjYXJkIGZvcm0gaXNcbiAgICAgKiBhY3RpdmUsIGFuIGVtcHR5IHF1ZXJ5IHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBTdHJpbmcgc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIGpRdWVyeVxuICAgICAqL1xuICAgIGZvcm1FbChzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBmb3JtID0gdGhpcy5nZXRBY3RpdmVTdHJpcGVTZXBhRm9ybSgpO1xuICAgICAgICByZXR1cm4gKGZvcm0pID8gZm9ybS5maW5kKHNlbGVjdG9yKSA6ICQoJ3N0cmlwZV9wYXltZW50X2JhbmtfYWNjb3VudF9ub3RfZm91bmQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGpRdWVyeSBUaGUgbWFpbiBwYXltZW50IHNlbGVjdGlvbiBmb3JtIGVsZW1lbnQuXG4gICAgICovXG4gICAgZmluZEZvcm0oKSB7XG4gICAgICAgIHJldHVybiAkKCcjY29uZmlybVBheW1lbnRGb3JtJyk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQURBO0FBREE7QUFDQTtBQVlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBOzs7Ozs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBSEE7QUFEQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUVBO0FBQ0E7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBbGRBO0FBQ0E7QUFEQTtBQUVBOzs7QUFHQTtBQUVBO0FBRUE7QUFFQTtBQVZBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///I6n5\n");

/***/ }),

/***/ "a+Fl":
/*!**************************************************************************************************************************************************************************!*\
  !*** /home/felix/PhpstormProjects/shopware-6/plugins/ShopwareStripePayment/src/Resources/storefront/digital-wallet-selection/stripe-payment.digital-wallet-selection.js ***!
  \**************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return StripePaymentDigitalWalletSelection; });\n/* harmony import */ var src_script_service_http_client_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/script/service/http-client.service */ \"k8s9\");\n/* harmony import */ var src_script_plugin_system_plugin_class__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/script/plugin-system/plugin.class */ \"FGIj\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable import/no-unresolved */\n\n\n\nvar StripePaymentDigitalWalletSelection =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(StripePaymentDigitalWalletSelection, _Plugin);\n\n  function StripePaymentDigitalWalletSelection() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, StripePaymentDigitalWalletSelection);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(StripePaymentDigitalWalletSelection)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"paymentApiAvailable\", false);\n\n    return _this;\n  }\n\n  _createClass(StripePaymentDigitalWalletSelection, [{\n    key: \"init\",\n    value: function init() {\n      this._client = new src_script_service_http_client_service__WEBPACK_IMPORTED_MODULE_0__[\"default\"](window.accessKey, window.contextToken);\n      this.options = _extends(StripePaymentDigitalWalletSelection.options, this.options || {});\n      /* eslint-disable no-undef */\n\n      this.stripeClient = Stripe(this.options.stripePublicKey);\n      this.paymentDisplayItems = this.options.lineItems.map(function (item) {\n        return {\n          label: item.articlename,\n          amount: Math.round(item.amountNumeric * 100)\n        };\n      });\n\n      if (this.options.shippingCost) {\n        this.paymentDisplayItems.push({\n          label: this.snippets.shippingCost,\n          amount: Math.round(this.options.shippingCost * 100)\n        });\n      }\n\n      this.createPaymentRequest(this.options.countryCode, this.options.currencyCode, this.options.statementDescriptor || '', this.options.amount);\n      this.findForm().on('submit', {\n        scope: this\n      }, this.onFormSubmission);\n    }\n  }, {\n    key: \"createPaymentRequest\",\n    value: function createPaymentRequest(countryCode, currencyCode, statementDescriptor, amount) {\n      var _this2 = this;\n\n      this.paymentRequest = this.stripeClient.paymentRequest({\n        country: countryCode.toUpperCase(),\n        currency: currencyCode.toLowerCase(),\n        total: {\n          label: statementDescriptor,\n          amount: Math.round(amount * 100)\n        },\n        displayItems: this.paymentDisplayItems\n      }); // Add a listener for once the payment is created. This happens once the user selects \"pay\" in his browser\n      // specific payment popup\n\n      this.paymentRequest.on('paymentmethod', function (paymentResponse) {\n        _this2.paymentMethodId = paymentResponse.paymentMethod.id; // Complete the browser's payment flow\n\n        paymentResponse.complete('success'); // Add the created Stripe token to the form and submit it\n\n        var form = _this2.findForm();\n\n        $('input[name=\"stripeDigitalWalletPaymentMethodId\"]').remove();\n        $('<input type=\"hidden\" name=\"stripeDigitalWalletPaymentMethodId\" />').val(_this2.paymentMethodId).appendTo(form);\n        form.submit();\n      }); // Add listener for cancelled payment flow\n\n      this.paymentRequest.on('cancel', function () {\n        _this2.paymentMethodId = null;\n\n        _this2.handleStripeError('payment cancelled');\n\n        _this2.resetSubmitButton();\n      }); // Check for availability of the payment api\n\n      this.paymentRequest.canMakePayment().then(function (result) {\n        _this2.paymentApiAvailable = !!result;\n\n        if (_this2.paymentApiAvailable) {\n          return;\n        }\n\n        if (!_this2.isSecureConnection()) {\n          _this2.handleStripeError('insecure connection');\n\n          return;\n        }\n\n        _this2.handleStripeError('not available');\n      });\n    }\n  }, {\n    key: \"isSecureConnection\",\n    value: function isSecureConnection() {\n      return window.location.protocol === 'https:';\n    }\n    /**\n     * First validates the form and payment state and, if the main form can be submitted, does nothing further.\n     * If however the main form cannot be submitted, because no card is selected (or no token was created), a new Stripe\n     * card and token are generated using the entered card data and saved in the form, before the submission is\n     * triggered again.\n     *\n     * @param event\n     */\n\n  }, {\n    key: \"onFormSubmission\",\n    value: function onFormSubmission(event) {\n      var me = event.data.scope;\n\n      if ($('input#tos').length === 1 && !$('input#tos').is(':checked')) {\n        return undefined;\n      } // Check if a Stripe payment method was generated and hence the form can be submitted\n\n\n      if (me.paymentMethodId) {\n        return undefined;\n      } // Prevent the form from being submitted until a new Stripe payment method is generated and received\n\n\n      event.preventDefault(); // We have to manually check whether this site is served via HTTPS before checking the digital wallet payments availability\n      // using Stripe.js. Even though Stripe.js checks the used protocol and declines the payment if not served via\n      // HTTPS, only a generic 'not available' error message is returned and the HTTPS warning is logged to the\n      // console. We however want to show a specific error message that informs about the lack of security.\n\n      if (!me.isSecureConnection()) {\n        me.shouldResetSubmitButton = true;\n        me.handleStripeError('insecure connection');\n        return undefined;\n      } // Check for general availability of the digital wallet payments\n\n\n      if (!me.paymentApiAvailable) {\n        me.shouldResetSubmitButton = true;\n        me.handleStripeError('payment api available');\n        return undefined;\n      }\n\n      $('#stripe-payment-checkout-error-box').hide();\n      me.setSubmitButtonLoading(); // Process the payment\n\n      me.paymentRequest.show();\n    }\n    /**\n     * Finds both submit buttons on the page and adds the 'disabled' attribute as well as the loading indicator to each\n     * of them.\n     */\n\n  }, {\n    key: \"setSubmitButtonLoading\",\n    value: function setSubmitButtonLoading() {\n      $('#confirmFormSubmit button[type=\"submit\"]').attr('disabled', 'disabled');\n    }\n    /**\n     * Finds both submit buttons on the page and resets them by removing the 'disabled' attribute as well as the\n     * loading indicator.\n     */\n\n  }, {\n    key: \"resetSubmitButton\",\n    value: function resetSubmitButton() {\n      $('#confirmFormSubmit button[type=\"submit\"]').removeAttr('disabled');\n    }\n    /**\n     * Sets the given message in the general error box and scrolls the page to make it visible.\n     *\n     * @param String message A Stripe error message.\n     */\n\n  }, {\n    key: \"handleStripeError\",\n    value: function handleStripeError(message) {\n      $('#stripe-payment-checkout-error-box').show().children('.error-content').html(message);\n    }\n    /**\n     * @return jQuery The main payment selection form element.\n     */\n\n  }, {\n    key: \"findForm\",\n    value: function findForm() {\n      return $('#confirmOrderForm');\n    }\n  }]);\n\n  return StripePaymentDigitalWalletSelection;\n}(src_script_plugin_system_plugin_class__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n_defineProperty(StripePaymentDigitalWalletSelection, \"options\", {\n  /**\n   * @type string\n   */\n  stripePublicKey: '',\n  locale: 'en',\n  lineItems: [],\n  countryCode: 'DE',\n  currencyCode: 'EUR',\n  amount: 123\n});\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! /home/felix/PhpstormProjects/shopware-6/shopware-development/vendor/shopware/platform/src/Storefront/Resources/node_modules/jquery/dist/jquery.slim.js */ \"wpjq\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYStGbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9mZWxpeC9QaHBzdG9ybVByb2plY3RzL3Nob3B3YXJlLTYvcGx1Z2lucy9TaG9wd2FyZVN0cmlwZVBheW1lbnQvc3JjL1Jlc291cmNlcy9zdG9yZWZyb250L2RpZ2l0YWwtd2FsbGV0LXNlbGVjdGlvbi9zdHJpcGUtcGF5bWVudC5kaWdpdGFsLXdhbGxldC1zZWxlY3Rpb24uanM/MGY0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tdW5yZXNvbHZlZCAqL1xuXG5pbXBvcnQgSHR0cENsaWVudCBmcm9tICdzcmMvc2NyaXB0L3NlcnZpY2UvaHR0cC1jbGllbnQuc2VydmljZSc7XG5pbXBvcnQgUGx1Z2luIGZyb20gJ3NyYy9zY3JpcHQvcGx1Z2luLXN5c3RlbS9wbHVnaW4uY2xhc3MnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpcGVQYXltZW50RGlnaXRhbFdhbGxldFNlbGVjdGlvbiBleHRlbmRzIFBsdWdpbiB7XG4gICAgc3RhdGljIG9wdGlvbnMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHN0cmlwZVB1YmxpY0tleTogJycsXG5cbiAgICAgICAgbG9jYWxlOiAnZW4nLFxuXG4gICAgICAgIGxpbmVJdGVtczogW10sXG5cbiAgICAgICAgY291bnRyeUNvZGU6ICdERScsXG5cbiAgICAgICAgY3VycmVuY3lDb2RlOiAnRVVSJyxcblxuICAgICAgICBhbW91bnQ6IDEyMyxcbiAgICB9O1xuXG4gICAgcGF5bWVudEFwaUF2YWlsYWJsZSA9IGZhbHNlO1xuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gbmV3IEh0dHBDbGllbnQod2luZG93LmFjY2Vzc0tleSwgd2luZG93LmNvbnRleHRUb2tlbik7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihTdHJpcGVQYXltZW50RGlnaXRhbFdhbGxldFNlbGVjdGlvbi5vcHRpb25zLCB0aGlzLm9wdGlvbnMgfHwge30pO1xuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgICAgIHRoaXMuc3RyaXBlQ2xpZW50ID0gU3RyaXBlKHRoaXMub3B0aW9ucy5zdHJpcGVQdWJsaWNLZXkpO1xuXG4gICAgICAgIHRoaXMucGF5bWVudERpc3BsYXlJdGVtcyA9IHRoaXMub3B0aW9ucy5saW5lSXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBpdGVtLmFydGljbGVuYW1lLFxuICAgICAgICAgICAgICAgIGFtb3VudDogTWF0aC5yb3VuZChpdGVtLmFtb3VudE51bWVyaWMgKiAxMDApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hpcHBpbmdDb3N0KSB7XG4gICAgICAgICAgICB0aGlzLnBheW1lbnREaXNwbGF5SXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuc25pcHBldHMuc2hpcHBpbmdDb3N0LFxuICAgICAgICAgICAgICAgIGFtb3VudDogTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMuc2hpcHBpbmdDb3N0ICogMTAwKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jcmVhdGVQYXltZW50UmVxdWVzdChcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jb3VudHJ5Q29kZSxcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jdXJyZW5jeUNvZGUsXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RhdGVtZW50RGVzY3JpcHRvciB8fCAnJyxcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbW91bnRcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmZpbmRGb3JtKCkub24oJ3N1Ym1pdCcsIHsgc2NvcGU6IHRoaXMgfSwgdGhpcy5vbkZvcm1TdWJtaXNzaW9uKTtcbiAgICB9XG5cbiAgICBjcmVhdGVQYXltZW50UmVxdWVzdChjb3VudHJ5Q29kZSwgY3VycmVuY3lDb2RlLCBzdGF0ZW1lbnREZXNjcmlwdG9yLCBhbW91bnQpIHtcbiAgICAgICAgdGhpcy5wYXltZW50UmVxdWVzdCA9IHRoaXMuc3RyaXBlQ2xpZW50LnBheW1lbnRSZXF1ZXN0KHtcbiAgICAgICAgICAgIGNvdW50cnk6IGNvdW50cnlDb2RlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3lDb2RlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICB0b3RhbDoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBzdGF0ZW1lbnREZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgIGFtb3VudDogTWF0aC5yb3VuZChhbW91bnQgKiAxMDApLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3BsYXlJdGVtczogdGhpcy5wYXltZW50RGlzcGxheUl0ZW1zLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgYSBsaXN0ZW5lciBmb3Igb25jZSB0aGUgcGF5bWVudCBpcyBjcmVhdGVkLiBUaGlzIGhhcHBlbnMgb25jZSB0aGUgdXNlciBzZWxlY3RzIFwicGF5XCIgaW4gaGlzIGJyb3dzZXJcbiAgICAgICAgLy8gc3BlY2lmaWMgcGF5bWVudCBwb3B1cFxuICAgICAgICB0aGlzLnBheW1lbnRSZXF1ZXN0Lm9uKCdwYXltZW50bWV0aG9kJywgKHBheW1lbnRSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXltZW50TWV0aG9kSWQgPSBwYXltZW50UmVzcG9uc2UucGF5bWVudE1ldGhvZC5pZDtcblxuICAgICAgICAgICAgLy8gQ29tcGxldGUgdGhlIGJyb3dzZXIncyBwYXltZW50IGZsb3dcbiAgICAgICAgICAgIHBheW1lbnRSZXNwb25zZS5jb21wbGV0ZSgnc3VjY2VzcycpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGNyZWF0ZWQgU3RyaXBlIHRva2VuIHRvIHRoZSBmb3JtIGFuZCBzdWJtaXQgaXRcbiAgICAgICAgICAgIGNvbnN0IGZvcm0gPSB0aGlzLmZpbmRGb3JtKCk7XG4gICAgICAgICAgICAkKCdpbnB1dFtuYW1lPVwic3RyaXBlRGlnaXRhbFdhbGxldFBheW1lbnRNZXRob2RJZFwiXScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgJCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwic3RyaXBlRGlnaXRhbFdhbGxldFBheW1lbnRNZXRob2RJZFwiIC8+JylcbiAgICAgICAgICAgICAgICAudmFsKHRoaXMucGF5bWVudE1ldGhvZElkKVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhmb3JtKTtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBsaXN0ZW5lciBmb3IgY2FuY2VsbGVkIHBheW1lbnQgZmxvd1xuICAgICAgICB0aGlzLnBheW1lbnRSZXF1ZXN0Lm9uKCdjYW5jZWwnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBheW1lbnRNZXRob2RJZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN0cmlwZUVycm9yKCdwYXltZW50IGNhbmNlbGxlZCcpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFN1Ym1pdEJ1dHRvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgYXZhaWxhYmlsaXR5IG9mIHRoZSBwYXltZW50IGFwaVxuICAgICAgICB0aGlzLnBheW1lbnRSZXF1ZXN0LmNhbk1ha2VQYXltZW50KCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBheW1lbnRBcGlBdmFpbGFibGUgPSAhIXJlc3VsdDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBheW1lbnRBcGlBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNTZWN1cmVDb25uZWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN0cmlwZUVycm9yKCdpbnNlY3VyZSBjb25uZWN0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN0cmlwZUVycm9yKCdub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlzU2VjdXJlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyc3QgdmFsaWRhdGVzIHRoZSBmb3JtIGFuZCBwYXltZW50IHN0YXRlIGFuZCwgaWYgdGhlIG1haW4gZm9ybSBjYW4gYmUgc3VibWl0dGVkLCBkb2VzIG5vdGhpbmcgZnVydGhlci5cbiAgICAgKiBJZiBob3dldmVyIHRoZSBtYWluIGZvcm0gY2Fubm90IGJlIHN1Ym1pdHRlZCwgYmVjYXVzZSBubyBjYXJkIGlzIHNlbGVjdGVkIChvciBubyB0b2tlbiB3YXMgY3JlYXRlZCksIGEgbmV3IFN0cmlwZVxuICAgICAqIGNhcmQgYW5kIHRva2VuIGFyZSBnZW5lcmF0ZWQgdXNpbmcgdGhlIGVudGVyZWQgY2FyZCBkYXRhIGFuZCBzYXZlZCBpbiB0aGUgZm9ybSwgYmVmb3JlIHRoZSBzdWJtaXNzaW9uIGlzXG4gICAgICogdHJpZ2dlcmVkIGFnYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgb25Gb3JtU3VibWlzc2lvbihldmVudCkge1xuICAgICAgICBjb25zdCBtZSA9IGV2ZW50LmRhdGEuc2NvcGU7XG5cbiAgICAgICAgaWYgKCQoJ2lucHV0I3RvcycpLmxlbmd0aCA9PT0gMSAmJiAhJCgnaW5wdXQjdG9zJykuaXMoJzpjaGVja2VkJykpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBhIFN0cmlwZSBwYXltZW50IG1ldGhvZCB3YXMgZ2VuZXJhdGVkIGFuZCBoZW5jZSB0aGUgZm9ybSBjYW4gYmUgc3VibWl0dGVkXG4gICAgICAgIGlmIChtZS5wYXltZW50TWV0aG9kSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBmb3JtIGZyb20gYmVpbmcgc3VibWl0dGVkIHVudGlsIGEgbmV3IFN0cmlwZSBwYXltZW50IG1ldGhvZCBpcyBnZW5lcmF0ZWQgYW5kIHJlY2VpdmVkXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gV2UgaGF2ZSB0byBtYW51YWxseSBjaGVjayB3aGV0aGVyIHRoaXMgc2l0ZSBpcyBzZXJ2ZWQgdmlhIEhUVFBTIGJlZm9yZSBjaGVja2luZyB0aGUgZGlnaXRhbCB3YWxsZXQgcGF5bWVudHMgYXZhaWxhYmlsaXR5XG4gICAgICAgIC8vIHVzaW5nIFN0cmlwZS5qcy4gRXZlbiB0aG91Z2ggU3RyaXBlLmpzIGNoZWNrcyB0aGUgdXNlZCBwcm90b2NvbCBhbmQgZGVjbGluZXMgdGhlIHBheW1lbnQgaWYgbm90IHNlcnZlZCB2aWFcbiAgICAgICAgLy8gSFRUUFMsIG9ubHkgYSBnZW5lcmljICdub3QgYXZhaWxhYmxlJyBlcnJvciBtZXNzYWdlIGlzIHJldHVybmVkIGFuZCB0aGUgSFRUUFMgd2FybmluZyBpcyBsb2dnZWQgdG8gdGhlXG4gICAgICAgIC8vIGNvbnNvbGUuIFdlIGhvd2V2ZXIgd2FudCB0byBzaG93IGEgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSB0aGF0IGluZm9ybXMgYWJvdXQgdGhlIGxhY2sgb2Ygc2VjdXJpdHkuXG4gICAgICAgIGlmICghbWUuaXNTZWN1cmVDb25uZWN0aW9uKCkpIHtcbiAgICAgICAgICAgIG1lLnNob3VsZFJlc2V0U3VibWl0QnV0dG9uID0gdHJ1ZTtcbiAgICAgICAgICAgIG1lLmhhbmRsZVN0cmlwZUVycm9yKCdpbnNlY3VyZSBjb25uZWN0aW9uJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgZ2VuZXJhbCBhdmFpbGFiaWxpdHkgb2YgdGhlIGRpZ2l0YWwgd2FsbGV0IHBheW1lbnRzXG4gICAgICAgIGlmICghbWUucGF5bWVudEFwaUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgbWUuc2hvdWxkUmVzZXRTdWJtaXRCdXR0b24gPSB0cnVlO1xuICAgICAgICAgICAgbWUuaGFuZGxlU3RyaXBlRXJyb3IoJ3BheW1lbnQgYXBpIGF2YWlsYWJsZScpO1xuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgJCgnI3N0cmlwZS1wYXltZW50LWNoZWNrb3V0LWVycm9yLWJveCcpLmhpZGUoKTtcblxuICAgICAgICBtZS5zZXRTdWJtaXRCdXR0b25Mb2FkaW5nKCk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgcGF5bWVudFxuICAgICAgICBtZS5wYXltZW50UmVxdWVzdC5zaG93KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYm90aCBzdWJtaXQgYnV0dG9ucyBvbiB0aGUgcGFnZSBhbmQgYWRkcyB0aGUgJ2Rpc2FibGVkJyBhdHRyaWJ1dGUgYXMgd2VsbCBhcyB0aGUgbG9hZGluZyBpbmRpY2F0b3IgdG8gZWFjaFxuICAgICAqIG9mIHRoZW0uXG4gICAgICovXG4gICAgc2V0U3VibWl0QnV0dG9uTG9hZGluZygpIHtcbiAgICAgICAgJCgnI2NvbmZpcm1Gb3JtU3VibWl0IGJ1dHRvblt0eXBlPVwic3VibWl0XCJdJykuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBib3RoIHN1Ym1pdCBidXR0b25zIG9uIHRoZSBwYWdlIGFuZCByZXNldHMgdGhlbSBieSByZW1vdmluZyB0aGUgJ2Rpc2FibGVkJyBhdHRyaWJ1dGUgYXMgd2VsbCBhcyB0aGVcbiAgICAgKiBsb2FkaW5nIGluZGljYXRvci5cbiAgICAgKi9cbiAgICByZXNldFN1Ym1pdEJ1dHRvbigpIHtcbiAgICAgICAgJCgnI2NvbmZpcm1Gb3JtU3VibWl0IGJ1dHRvblt0eXBlPVwic3VibWl0XCJdJykucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiBtZXNzYWdlIGluIHRoZSBnZW5lcmFsIGVycm9yIGJveCBhbmQgc2Nyb2xscyB0aGUgcGFnZSB0byBtYWtlIGl0IHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gU3RyaW5nIG1lc3NhZ2UgQSBTdHJpcGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBoYW5kbGVTdHJpcGVFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICQoJyNzdHJpcGUtcGF5bWVudC1jaGVja291dC1lcnJvci1ib3gnKS5zaG93KCkuY2hpbGRyZW4oJy5lcnJvci1jb250ZW50JykuaHRtbChtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGpRdWVyeSBUaGUgbWFpbiBwYXltZW50IHNlbGVjdGlvbiBmb3JtIGVsZW1lbnQuXG4gICAgICovXG4gICAgZmluZEZvcm0oKSB7XG4gICAgICAgIHJldHVybiAkKCcjY29uZmlybU9yZGVyRm9ybScpO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFDQTs7Ozs7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBT0E7QUFBQTtBQUFBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFQQTtBQVdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBekxBO0FBQ0E7QUFEQTtBQUVBOzs7QUFHQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFkQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///a+Fl\n");

/***/ }),

/***/ "qW9D":
/*!**************************************************************************************************************!*\
  !*** /home/felix/PhpstormProjects/shopware-6/plugins/ShopwareStripePayment/src/Resources/storefront/main.js ***!
  \**************************************************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _card_selection_stripe_payment_card_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./card-selection/stripe-payment.card-selection */ \"/TfR\");\n/* harmony import */ var _sepa_selection_stripe_payment_sepa_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sepa-selection/stripe-payment.sepa-selection */ \"I6n5\");\n/* harmony import */ var _digital_wallet_selection_stripe_payment_digital_wallet_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./digital-wallet-selection/stripe-payment.digital-wallet-selection */ \"a+Fl\");\n// Import all necessary Storefront plugins and scss files\n\n\n // Register them via the existing PluginManager\n\nvar PluginManager = window.PluginManager;\nPluginManager.register('StripePaymentCardSelection', _card_selection_stripe_payment_card_selection__WEBPACK_IMPORTED_MODULE_0__[\"default\"], '[data-stripe-payment-card-selection]');\nPluginManager.register('StripePaymentSepaSelection', _sepa_selection_stripe_payment_sepa_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"], '[data-stripe-payment-sepa-selection]');\nPluginManager.register('StripePaymentDigitalWalletSelection', _digital_wallet_selection_stripe_payment_digital_wallet_selection__WEBPACK_IMPORTED_MODULE_2__[\"default\"], '[data-stripe-payment-digital-wallet-selection]'); //Necessary for the webpack hot module reloading server\n\nif (false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicVc5RC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9mZWxpeC9QaHBzdG9ybVByb2plY3RzL3Nob3B3YXJlLTYvcGx1Z2lucy9TaG9wd2FyZVN0cmlwZVBheW1lbnQvc3JjL1Jlc291cmNlcy9zdG9yZWZyb250L21haW4uanM/MjkzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnQgYWxsIG5lY2Vzc2FyeSBTdG9yZWZyb250IHBsdWdpbnMgYW5kIHNjc3MgZmlsZXNcbmltcG9ydCBTdHJpcGVQYXltZW50Q2FyZFNlbGVjdGlvbiBmcm9tICcuL2NhcmQtc2VsZWN0aW9uL3N0cmlwZS1wYXltZW50LmNhcmQtc2VsZWN0aW9uJztcbmltcG9ydCBTdHJpcGVQYXltZW50U2VwYVNlbGVjdGlvbiBmcm9tICcuL3NlcGEtc2VsZWN0aW9uL3N0cmlwZS1wYXltZW50LnNlcGEtc2VsZWN0aW9uJztcbmltcG9ydCBTdHJpcGVQYXltZW50RGlnaXRhbFdhbGxldFNlbGVjdGlvbiBmcm9tICcuL2RpZ2l0YWwtd2FsbGV0LXNlbGVjdGlvbi9zdHJpcGUtcGF5bWVudC5kaWdpdGFsLXdhbGxldC1zZWxlY3Rpb24nO1xuXG4vLyBSZWdpc3RlciB0aGVtIHZpYSB0aGUgZXhpc3RpbmcgUGx1Z2luTWFuYWdlclxuY29uc3QgUGx1Z2luTWFuYWdlciA9IHdpbmRvdy5QbHVnaW5NYW5hZ2VyO1xuUGx1Z2luTWFuYWdlci5yZWdpc3RlcignU3RyaXBlUGF5bWVudENhcmRTZWxlY3Rpb24nLCBTdHJpcGVQYXltZW50Q2FyZFNlbGVjdGlvbiwgJ1tkYXRhLXN0cmlwZS1wYXltZW50LWNhcmQtc2VsZWN0aW9uXScpO1xuUGx1Z2luTWFuYWdlci5yZWdpc3RlcignU3RyaXBlUGF5bWVudFNlcGFTZWxlY3Rpb24nLCBTdHJpcGVQYXltZW50U2VwYVNlbGVjdGlvbiwgJ1tkYXRhLXN0cmlwZS1wYXltZW50LXNlcGEtc2VsZWN0aW9uXScpO1xuUGx1Z2luTWFuYWdlci5yZWdpc3RlcignU3RyaXBlUGF5bWVudERpZ2l0YWxXYWxsZXRTZWxlY3Rpb24nLCBTdHJpcGVQYXltZW50RGlnaXRhbFdhbGxldFNlbGVjdGlvbiwgJ1tkYXRhLXN0cmlwZS1wYXltZW50LWRpZ2l0YWwtd2FsbGV0LXNlbGVjdGlvbl0nKTtcblxuXG4vL05lY2Vzc2FyeSBmb3IgdGhlIHdlYnBhY2sgaG90IG1vZHVsZSByZWxvYWRpbmcgc2VydmVyXG5pZiAobW9kdWxlLmhvdCkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KCk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///qW9D\n");

/***/ })

},[["qW9D","runtime","vendor-node","vendor-shared"]]]);